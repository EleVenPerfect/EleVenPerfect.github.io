<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>扒一扒那些诈骗邮件套路</title>
    <link href="/2019/01/14/%E6%89%92%E4%B8%80%E6%89%92%E9%82%A3%E4%BA%9B%E8%AF%88%E9%AA%97%E9%82%AE%E4%BB%B6%E5%A5%97%E8%B7%AF/"/>
    <url>/2019/01/14/%E6%89%92%E4%B8%80%E6%89%92%E9%82%A3%E4%BA%9B%E8%AF%88%E9%AA%97%E9%82%AE%E4%BB%B6%E5%A5%97%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>好久没更新啦，最近发生件很有意思的事，分享给大家~</p><p>发生了什么呢？直接看图片吧~</p><p><img src="/images/img_5c3c2f999dda3.png"></p><h2 id="啥？我居然中病毒了？"><a href="#啥？我居然中病毒了？" class="headerlink" title="啥？我居然中病毒了？"></a>啥？我居然中病毒了？</h2><p><img src="/images/img_5c3c2f6f47f5e.png"></p><p>收到这个我表示，说的好吓人啊，but，你逗我呢么？然而又一想，为啥他居然知道我密码呢？好像确实有病毒？本来想着算了，反正知道是骗子就不理他就行了，结果这家伙貌似发邮件根本停不下来啊，所以让我来彻底查一查</p><h2 id="首先，邮件里说我反查不到他是谁？"><a href="#首先，邮件里说我反查不到他是谁？" class="headerlink" title="首先，邮件里说我反查不到他是谁？"></a>首先，邮件里说我反查不到他是谁？</h2><p>有着建站经验的我，当然要先查查邮件发件域名是谁的~</p><p>直接到搜索whois查询，找到这个：</p><p><a href="https://www.whois.com/whois/">https://www.whois.com/whois/</a></p><p><img src="/images/img_5c3c2f2d5f2b3.png"></p><p>查了一下这三封邮件的发件域名，都是未注册，厉害了，居然还真找不到他</p><p><img src="/images/img_5c3c309985072.png"></p><p>猜测是发件使用的是快要过期的域名？但一般过期也会有痕迹，近期过期域名不会立即删除，而已经过期域名就会取消解析发不出邮件，这时为啥呢？进过一番研究发现，原来是这样：</p><blockquote><p>由于邮件发送使用的SMTP协议的信头可以任意构造，部分邮件服务商转发邮件不进行相互认证，因此其“from：”字段可以任意修改，在邮件中显示为任意发信人。但对多数主流邮件服务商（ESP），这种邮件都会被反垃圾邮件功能主动拦截过滤，市面上常见的邮箱提供商都支持对此类垃圾邮件的过滤功能，包括直接拒绝接收该邮件。</p></blockquote><p>因此，这些诈骗邮件只不过是随便写的发件地址，他甚至可以写成和你的邮件相同的地址，让你误以为是他黑进你的邮箱。</p><p>通过查找比特币收款地址 <a href="https://bitcoinwhoswho.com/">https://bitcoinwhoswho.com/</a></p><p>可以查询邮件中的收款情况：</p><p><img src="/images/img_5c3c32d126836.png"></p><p><img src="/images/img_5c3c3300d6645.png"></p><p><img src="/images/img_5c3c332ddaa91.png"></p><p>还真有个别人给他比特币了，然而<del>哈哈哈哈</del></p><p>这样可以进一步确定邮件是诈骗邮件了，但还有一件事很重要：</p><h2 id="他怎么知道我曾用过的密码的呢？"><a href="#他怎么知道我曾用过的密码的呢？" class="headerlink" title="他怎么知道我曾用过的密码的呢？"></a>他怎么知道我曾用过的密码的呢？</h2><p>通过使用<a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a>提供的服务，可以查询自己使用邮箱是否有泄露的网站账户密码：</p><p><img src="/images/img_5c3c33e9a7e1c.png"></p><p>搜索一下:</p><p><img src="/images/img_5c3c3428859ef.png"></p><p>红色就有表示已经有密码泄露啦</p><p>下拉可以看到那些网站泄露，并查看泄露详情：</p><p><img src="/images/img_5c3c348e10d40.png"></p><p>网站推荐使用1Password 工具来保护自己的密码。</p><p>通过分别查看自己的注册邮箱和密码，可以确认，收到的邮件是得到了000webhost数据库中的密码，查询自己的邮件记录发现，000webhost在之前也已经发送密码泄露通知并道歉了。</p><p>这样事情就真相大白了，邮件里的黑客并不是什么黑客，他也没有入侵你的电脑，只不过是找到了你泄露的网站注册信息，通过修改发送邮件的方式，伪装成黑客，群发勒索邮件。对于这种邮件，我们只需要忽略就可以咯。</p><h2 id="如何保证密码安全？"><a href="#如何保证密码安全？" class="headerlink" title="如何保证密码安全？"></a>如何保证密码安全？</h2><p>这里ATIME建议使用密码管理软件来管理自己的密码，而不要让多个网站账户使用相同的账号密码，这样可以大大降低账户被盗风险。目前，我是用的是LastPass软件，支持浏览器和手机端同步使用，还有1Password亦可以尝试一下，体验也很不错~</p><p>对于已经泄露出来的密码，建议赶紧把自己账户有相关密码的网站统统改成其他密码，防止别人撞库，LastPass提供了自动生成密码的功能，可以很方便的生成随机复杂的密码，每个网站使用LastPass生成的随机密码可以有效防止别的得到一个密码而轻易登录到你的各个网站账户。</p><p>最后，放上我的推荐软件地址：<a href="https://lastpass.com/f?15137702">https://lastpass.com/f?15137702</a></p><p>也可以扫描二维码：</p><p><img src="/images/9b01a3407973b647b19c02ddac59c49a.png"></p><p>快快下载体验吧，用我的邀请链接还可以获得免费体验高级会员功能哦~</p><p>欢迎关注我的微信公众号，谢谢！</p><p><img src="/images/gzh.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站建设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATIME 五年</title>
    <link href="/2018/10/10/atime-%E4%BA%94%E5%B9%B4/"/>
    <url>/2018/10/10/atime-%E4%BA%94%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<p>ATIME 这个词已经伴随我整整五年了，回想那么多人出现在人生轨迹里，回看那时候还不够成熟、还在耍小脾气的我，不得不谢谢陪伴我的人，能容忍我那么胡闹。</p><p>读研让我看到更多有趣的人，有意思的事，也让我更加看清自己，期待自己能创造属于自己的神话。</p><p>ATIME，专注创造奇迹！</p><p>By ATIME 20181011</p>]]></content>
    
    
    <categories>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过ifttt/rss实现网站通知即刻获取</title>
    <link href="/2018/06/09/%E9%80%9A%E8%BF%87ifttt-rss%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E9%80%9A%E7%9F%A5%E5%8D%B3%E5%88%BB%E8%8E%B7%E5%8F%96/"/>
    <url>/2018/06/09/%E9%80%9A%E8%BF%87ifttt-rss%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E9%80%9A%E7%9F%A5%E5%8D%B3%E5%88%BB%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一、问题阐述"><a href="#一、问题阐述" class="headerlink" title="一、问题阐述"></a>一、问题阐述</h2><p>官方通知总是悄悄在官网更新？工作太忙没时间天天关注官网？工作中忘乎所以错过通知时间？我们需要一个高效可靠的网站更新通知。 当网站内容发生变换时，我么想要第一时间知道内容更新，我们需要一套可靠的网站通知工具，而目前还没有一个轻量化的解决方案。 本文利用ifttt和rss技术解决这一问题。</p><h2 id="二、什么是ifttt"><a href="#二、什么是ifttt" class="headerlink" title="二、什么是ifttt"></a>二、什么是ifttt</h2><p>ifttt是“if this then that”的缩写，事实上是让你的网络行为能够引发连锁反应、让你使用更为方便，其宗旨是“Put the internet to work for you”（让互联网为你服务）。 ifttt可以实现很多功能，这里用ifttt监测网站的RSS内容更新，并根据RSS更新通知我们。 首先我们需要注册一个ifttt账号，注册过程很简单，这里就不复述。这里建议安装一个手机APP，然后进入下一步。</p><h2 id="三、feed43-rss订阅"><a href="#三、feed43-rss订阅" class="headerlink" title="三、feed43 rss订阅"></a>三、feed43 rss订阅</h2><p>RSS是一项基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。 但实际上，并不是每个网站都提供RSS支持，因此这里介绍feed43来实现网站RSS自动生成，将没有RSS的网站自动生成RSS内容。 首先需要注册一个feed43账号，然后下面以中国证券协会的考试通知网址为例子。</p><h2 id="四、feed43结合ifttt"><a href="#四、feed43结合ifttt" class="headerlink" title="四、feed43结合ifttt"></a>四、feed43结合ifttt</h2><p>这里以中国证券协会的考试通知网址为例子，通知发布网址如下： <a href="http://www.sac.net.cn/cyry/kspt/kstz/">http://www.sac.net.cn/cyry/kspt/kstz/</a></p><p><img src="/images/img_5b1bd552034a6.png"></p><p>我们需要蓝色框内的内容 我们进入feed43网站 添加新feed：</p><p><img src="/images/img_5b1bd55ed747e.png"></p><p>输入需要的网址：</p><p><img src="/images/img_5b1bd568ac1eb.png"></p><p>点击reload获取html数据，根据html页面的内容特点，这里选择如下设置：</p><p><img src="/images/img_5b1bd5765f939.png"></p><p>然后设置输出格式：</p><p><img src="/images/img_5b1bd5832e963.png"></p><p>点击Preview进行预览，如无问题保存url即可。</p><p><img src="/images/img_5b1bd58b472b4.png"></p><p>在ifttt中添加if内容为RSS发生更新：<a href="http://feed43.com/3046477014485141.xml">http://feed43.com/3046477014485141.xml</a> 在ifttt中添加that内容为发送邮件到指定账户或者选择APP内VOIP通知即可，如图所示：</p><p><img src="/images/img_5b1bd59ac15cb.png"></p><p>添加新feed更新监测地址：</p><p><img src="/images/img_5b1bd5b057b64.png"></p><p>点击Creat trigger即可。</p><p>设置that事件，这里以发送email为例子：</p><p><img src="/images/img_5b1bd5dcd11e3.png"></p><p>点击send me an email</p><p><img src="/images/img_5b1bd5bb66e04.png"></p><p>点击下方finish即可完成设置。</p><p>设置完成，如图所示。</p><p><img src="/images/img_5b1bd5e9862ef.png"></p>]]></content>
    
    
    <categories>
      
      <category>crawler</category>
      
      <category>web</category>
      
      <category>essayist</category>
      
    </categories>
    
    
    <tags>
      
      <tag>feed43</tag>
      
      <tag>ifttt</tag>
      
      <tag>rss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wordpress博客添加微博动态</title>
    <link href="/2018/06/07/wordpress%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%BE%AE%E5%8D%9A%E5%8A%A8%E6%80%81/"/>
    <url>/2018/06/07/wordpress%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%BE%AE%E5%8D%9A%E5%8A%A8%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="首先去微博官方网站申请微博挂件"><a href="#首先去微博官方网站申请微博挂件" class="headerlink" title="首先去微博官方网站申请微博挂件"></a>首先去微博官方网站申请微博挂件</h2><p>地址：</p><p><a href="http://app.weibo.com/tool/blogwidget">http://app.weibo.com/tool/blogwidget</a></p><p>如图所示：</p><p><img src="/images/img_5b18ea2572d65.png"></p><p>可以选择HTML版，点击进入：</p><p><img src="/images/img_5b18ea30e7cd1.png"></p><p>复制文本框内的全部代码</p><h2 id="然后进入wordpress管理后台"><a href="#然后进入wordpress管理后台" class="headerlink" title="然后进入wordpress管理后台"></a>然后进入wordpress管理后台</h2><p>进入外观-小工具，找到自定义HTML，拖动到侧边栏工具</p><p><img src="/images/img_5b18ea4260ac8.png"></p><p>将代码粘贴到内容框内，如上图所示，保存后回到网站前台即可看到侧边栏微博微博。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
      <tag>微博</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Illenium - Needed You</title>
    <link href="/2018/04/07/illenium-needed-you/"/>
    <url>/2018/04/07/illenium-needed-you/</url>
    
    <content type="html"><![CDATA[<p>[music]507585222[&#x2F;music]</p><p>I could count them if I want to 如果你想 我可以为你细数 All these years I’ve wasted on you 我曾在你身上浪费的光阴无数 You gave up, I-I grew up 你将爱抛弃 我得到了教训 Oh, I can’t help, but wonder 但我还是 不住好奇</p><p>Where would I, where would I be? 哪里才是我的归宿</p><p>What would I do? 我应该做些什么 If you were, if you were there when I needed you 如果在我需要你的时刻 你就在一旁守候着 Where would I, where would I be? 哪里才是我的归宿 What would I do? 我应该做些什么 If you were, if you were there when I needed you 如果在我需要你的时刻 你就在一旁守候着 What would I-I do, I do, I do, needed you 我会做些什么，渴求着你 I do, I do, I do, needed you 我对你真心渴求</p><p>What would I 我该（做些什么）</p><p>I could count them if I want to 如果你想 我可以为你细数 All these years I’ve wasted on you 我曾在你身上浪费的光阴无数 You gave up, I-I grew up 你将爱抛弃 我得到了教训 Oh, I can’t tell, but wander 但我还是 不住好奇</p><p>Where would I, where would I be? 哪里才是我的归宿 What would I do? 我应该做些什么 If you were, if you were there when I needed you 如果在我需要你的时刻 你就在一旁守候着 Where would I, where would I be? 哪里才是我的归宿 What would I do? 我应该做些什么 If you were, if you were there when I needed you 如果在我需要你的时刻 你就在一旁守候着 What would I-I do, I do, I do, needed you 我会做些什么，渴求着你 I do, I do, I do, needed you 我对你真心渴求</p><p>What would I 我该（做些什么）</p>]]></content>
    
    
    <categories>
      
      <category>essayist</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>德古拉元年 - 摘抄</title>
    <link href="/2018/03/17/%E5%BE%B7%E5%8F%A4%E6%8B%89%E5%85%83%E5%B9%B4-%E6%91%98%E6%8A%84/"/>
    <url>/2018/03/17/%E5%BE%B7%E5%8F%A4%E6%8B%89%E5%85%83%E5%B9%B4-%E6%91%98%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<p>“Why think separately of this life than the next, when one is born from the last? Time is always too short for those who need it, but for those who love, it lasts forever.”</p><p>当我们能够再续前缘，又为何认定来世并非今生。</p><p>时间对需要它的人来说永远不够，但对相爱的人来说，时间是永恒的。</p><p>I now know hell is real</p><p>So I know there’s a heaven</p><p>Neither this world nor the next shall keep us apart</p><p>I will honor your sacrifice and I vow that our son shall be safe.</p><p>我现在知道地狱是真实的</p><p>所以我知道有天堂</p><p>这个世界和另一个世界都不能使我们分开。</p><p>我将尊重你的牺牲，我发誓我们的儿子将是安全的。</p><p>The Turks never conquered The capitals of Europe.</p><p>土耳其人也未完成称霸欧洲大业</p><p>His sacrifice taught me,that even after the darkest night the sun will rise again.</p><p>他的牺牲让我明白即使在最黑暗的夜晚后太阳依旧会升起.</p><p>For if the heart is strong enough,the soul is reborn.</p><p>因为如果心性够坚强 灵魂也能重生</p><p>I think separately of this life than the next, when one is born from the last. When one is born of the last.</p><p>既然人生于前生，为何还要将此生与来生分开。</p><p>It speaks to your yearning, of one soul pleading for another.</p><p>它说出了你的渴望 一个灵魂寻找着另一半。</p><hr><p>Look at love how it tangles with the one fallen in love</p><p>看爱如何纠缠堕入情网的人</p><p>Look at spirit how it fuses with earth giving it new life</p><p>看精神如何融合尘世并赋予它生命</p><p>Why are you so busy with this or that or good or bad</p><p>pay attention to how things blend</p><p>为什么你要汲汲营营于这个或那个或好或坏</p><p>注意事物是如何融合的</p><p>Why talk about all the known and the unknown</p><p>see how unknown merges into the known</p><p>为什么要谈所有已知和未知的东西</p><p>看未知如何融入已知。</p><p>Why think separately of this life and the next when one is born from the last</p><p>当一个人诞生于最后一生，为什么还要分别去思考此生与来生？</p><p>Look at your heart and tongue</p><p>one feels but deaf and numb</p><p>the other speaks in words and signs</p><p>看你的心和舌头</p><p>一个人只感觉到既聋又蠢</p><p>另一个人用文字和符号来诉说</p><p>Look at water and fire</p><p>earth and wind</p><p>enemies and friends all at once</p><p>同时一起看水与火</p><p>土与风</p><p>敌人与朋友</p><p>The wolf and the lamb</p><p>the lion and the deer</p><p>far away yet together</p><p>狼与羊</p><p>狮与鹿</p><p>远远分开却也在一起</p><p>Look at the unity of this</p><p>spring and winter</p><p>manifested in the equinox</p><p>看这结合</p><p>春天与冬天</p><p>出现在春分或秋分</p><p>You too must mingle my friends</p><p>since the earth and the sky</p><p>are mingled just for you and me</p><p>你也必须与我的朋友融合</p><p>因为地与天空</p><p>只为你与我而融合</p><p>Be like sugarcane</p><p>sweet yet silent</p><p>don’t get mixed up with bitter words</p><p>要像甘蔗</p><p>甜蜜却无声</p><p>别和痛苦的文字搅和</p><p>My beloved grows right out of my own heart</p><p>how much more union can there be</p><p>我的至爱正在我自己的心中长大</p><p>怎能有其它更多的结合</p><p><img src="/images/%E5%BE%B7%E5%8F%A4%E6%8B%89%E5%85%83%E5%B9%B4.png"></p>]]></content>
    
    
    <categories>
      
      <category>essayist</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>程序员技术练级攻略(转载)</title>
    <link href="/2018/02/15/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%E8%BD%AC%E8%BD%BD/"/>
    <url>/2018/02/15/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5%E8%BD%AC%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>月光博客6月12日发表了《<a href="http://www.williamlong.info/archives/2700.html">写给新手程序员的一封信</a>》，翻译自《<a href="http://blog.akash.im/an-open-letter-to-those-who-want-to-start">An open letter to those who want to start programming</a>》，我的朋友（他在本站的id是<a href="http://coolshell.cn/?author=3">Mailper</a>）告诉我，他希望在酷壳上看到一篇更具操作性的文章。因为他也是喜欢编程和技术的家伙，于是，我让他把他的一些学习Python和Web编程的一些点滴总结一下。于是他给我发来了一些他的心得和经历，我在把他的心得做了不多的增改，并根据我的经历增加了“进阶”一节。这是一篇由新手和我这个老家伙根据我们的经历完成的文章。</p><p>我的这个朋友把这篇文章取名叫Build Your Programming Technical Skills，我实在不知道用中文怎么翻译，但我在写的过程中，我觉得这很像一个打网游做任务升级的一个过程，所以取名叫“技术练级攻略”，题目有点大，呵呵，这个标题纯粹是为了好玩。这里仅仅是在分享Mailper和我个人的学习经历。（注：省去了我作为一个初学者曾经学习过的一些技术(今天明显过时了)，如：Delphi&#x2F;Power builder，也省去了我学过的一些我觉得没意思的技术Lotus Notes&#x2F;ActiveX&#x2F;COM&#x2F;ADO&#x2F;ATL&#x2F;.NET ……）</p><p>前言</p><p>你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，作业项目都看不出有什么实际作用，不如从工作中的需求出发）</p><p>建议：</p><ul><li>不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累而且还会在未来至少10年通用。</li><li>回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。</li><li>一定要动手，例子不管多么简单，建议至少自己手敲一遍看看是否理解了里头的细枝末节。</li><li>一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。</li></ul><p>注：你也许会很奇怪为什么下面的东西很偏Unix&#x2F;Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下：</p><ul><li>现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。</li><li>越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。</li><li>微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《<a href="http://coolshell.cn/articles/3008.html">Windows编程革命史</a>》</li></ul><p>所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。</p><p>启蒙入门</p><p>1、 学习一门脚本语言，例如Python&#x2F;Ruby</p><p>可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目:</p><ul><li>处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）</li><li>遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果</li><li>跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量</li><li>学会用各种print之类简单粗暴的方式进行调试</li><li>学会用Google (phrase, domain, use reader to follow tech blogs)</li></ul><p>为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。</p><p>2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具</p><ul><li>Vim &#x2F; Emacs &#x2F; Notepad++，学会如何配置代码补全，外观，外部命令等。</li><li>Source Insight (或 ctag)</li></ul><p>使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码&#x2F;配置文章&#x2F;日志会更快更有效率。</p><p>3、 熟悉Unix&#x2F;Linux Shell和常见的命令行</p><ul><li>如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧</li><li>一定要少用少用图形界面。</li><li>学会使用man来查看帮助</li><li>文件系统结构和基本操作 ls&#x2F;chmod&#x2F;chown&#x2F;rm&#x2F;find&#x2F;ln&#x2F;cat&#x2F;mount&#x2F;mkdir&#x2F;tar&#x2F;gzip …</li><li>学会使用一些文本操作命令 sed&#x2F;awk&#x2F;grep&#x2F;tail&#x2F;less&#x2F;more …</li><li>学会使用一些管理命令 ps&#x2F;top&#x2F;lsof&#x2F;netstat&#x2F;kill&#x2F;tcpdump&#x2F;iptables&#x2F;dd…</li><li>了解&#x2F;etc目录下的各种配置文章，学会查看&#x2F;var&#x2F;log下的系统日志，以及&#x2F;proc下的系统运行信息</li><li>了解正则表达式，使用正则表达式来查找文件。</li></ul><p>对于程序员来说Unix&#x2F;Linux比Windows简单多了。（参看我四年前CSDN的博文《<a href="http://blog.csdn.net/haoel/article/details/1533720">其实Unix很简单</a>》）学会使用Unix&#x2F;Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。</p><p>4、 学习Web基础（HTML&#x2F;CSS&#x2F;JS) + 服务器端技术 (LAMP)</p><p>未来必然是Web的世界，学习WEB基础的最佳网站是<a href="http://www.w3school.com.cn/">W3School</a>。</p><ul><li>学习HTML基本语法</li><li>学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）</li><li>学会用  Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。</li><li>学习使用Javascript操纵HTML元件。理解DOM和动态网页（<a href="http://oreilly.com/catalog/9780596527402">http://oreilly.com/catalog/9780596527402</a>) 网上有免费的章节，足够用了。或参看 <a href="http://www.w3school.com.cn/htmldom/index.asp">DOM</a> 。</li><li>学会用  Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）</li><li>在一台机器上配置<a href="http://coolshell.cn/articles/www.apache.org">Apache</a> 或 <a href="http://coolshell.cn/articles/nginx.net">Nginx</a></li><li>学习<a href="http://www.php.net/">PHP</a>，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。</li><li>把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）</li><li>跟完一个名校的网络编程课程（例如：<a href="http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php">http://www.stanford.edu/~ouster&#x2F;cgi-bin&#x2F;cs142-fall10&#x2F;index.php</a> ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上</li><li>学习一个javascript库（例如jQuery 或 ExtJS）+  Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。</li><li>HTTP: The Definite Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)</li><li>做个小网站（例如：一个小的留言板，支持用户登录，Cookie&#x2F;Session，增、删、改、查，上传图片附件，分页显示）</li><li>买个域名，租个空间，做个自己的网站。</li></ul><p>进阶加深</p><p>1、 C语言和操作系统调用</p><ul><li>重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《<a href="http://product.china-pub.com/197050">计算机程序设计艺术</a>》、《<a href="http://product.china-pub.com/31701">算法导论</a>》和《<a href="http://product.china-pub.com/209243">编程珠玑</a>》。</li><li>学习<a href="http://coolshell.cn/articles/3723.html">（麻省理工免费课程）计算机科学和编程导论</a></li><li>学习<a href="http://coolshell.cn/articles/2474.html">（麻省理工免费课程）C语言内存管理</a></li><li>学习Unix&#x2F;Linux系统调用（<a href="http://product.china-pub.com/30181">Unix高级环境编程</a>），，了解系统层面的东西。<ul><li>用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）</li><li>用fork&#x2F;wait&#x2F;waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。</li><li>用signal&#x2F;kill&#x2F;raise&#x2F;alarm&#x2F;pause&#x2F;sigprocmask实现一个多进程间的信号量通信的程序。</li><li>学会使用gcc和gdb来编程和调试程序（参看我的《<a href="http://coolshell.cn/articles/blog.csdn.net/haoel/article/details/2879">用gdb调试程序</a>》）</li><li>学会使用makefile来编译程序。（参看我的《<a href="http://coolshell.cn/articles/blog.csdn.net/haoel/article/details/2886">跟我一起写makefile</a>》）</li><li>IPC和Socket的东西可以放到高级中来实践。</li></ul></li><li>学习Windows SDK编程（<a href="http://product.china-pub.com/52880">Windows 程序设计</a> ，<a href="http://product.china-pub.com/3804">MFC程序设计</a>）<ul><li>写一个窗口，了解WinMain&#x2F;WinProcedure，以及Windows的消息机制。</li><li>写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。</li><li>学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。</li><li>这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。</li><li>不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@<a href="http://twitter.com/#!/virushuo">virushuo</a> 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac&#x2F;iOS上学”。</li></ul></li></ul><p>2、学习Java</p><ul><li>Java 的学习主要是看经典的Core Java 《<a href="http://product.china-pub.com/208978">Java 核心技术编程</a>》和《<a href="http://product.china-pub.com/34838">Java编程思想</a>》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）</li><li>学习JDK，学会查阅Java API Doc <a href="http://download.oracle.com/javase/6/docs/api/">http://download.oracle.com/javase/6/docs/api/</a></li><li>了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。</li><li>学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。</li><li>建一个Tomcat的网站，尝试一下JSP&#x2F;Servlet&#x2F;JDBC&#x2F;MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。</li></ul><p>3、Web的安全与架构</p><ul><li>学习HTML5，网上有很多很多教程，以前<a href="http://coolshell.cn/">酷壳</a>也介绍过很多，我在这里就不罗列了。</li><li>学习Web开发的安全问题（参考<a href="http://coolshell.cn/articles/4914.html">新浪微博被攻击的这个事</a>，以及<a href="http://guides.rubyonrails.org/security.html">Ruby的这篇文章</a>）</li><li>学习HTTP Server的rewrite机制，Nginx的反向代理机制，<a href="http://en.wikipedia.org/wiki/Fast_CGI">fast-cgi</a>（如：<a href="http://php-fpm.org/">PHP-FPM</a>）</li><li>学习Web的静态页面缓存技术。</li><li>学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。</li><li>实践任务：<ul><li>使用HTML5的canvas 制作一些Web动画。</li><li>尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。</li><li>把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站</li></ul></li></ul><p>4、一些开发工具</p><ul><li>学会使用SVN或Git来管理程序版本。</li><li>学会使用JUnit来对Java进行单元测试。</li><li>学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《<a href="http://blog.csdn.net/haoel/article/category/9200/2">编程修养</a>》，这样的东西你可以上网查一下，一大堆）。</li><li>推荐阅读《<a href="http://product.china-pub.com/28351">代码大全</a>》《<a href="http://product.china-pub.com/196374">重构</a>》《<a href="http://product.china-pub.com/196266">代码整洁之道</a>》</li></ul><p>高级深入</p><p>1、C++ &#x2F; Java 和面向对象</p><p>我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“<a href="http://coolshell.cn/articles/2287.html">C++学习信心图</a>” 和“<a href="http://coolshell.cn/articles/2250.html">21天学好C++</a>”</p><ul><li>学习<a href="http://coolshell.cn/articles/2474.html">（麻省理工免费课程）C++面向对象编程</a></li><li>读我的 “<a href="http://coolshell.cn/articles/4119.html">如何学好C++</a>”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《<a href="http://blog.csdn.net/haoel/article/details/1948051">C++虚函数表解析</a>》或是《<a href="http://blog.csdn.net/haoel/article/details/3081328">C++对象内存存局</a>（<a href="http://blog.csdn.net/haoel/article/details/3081328">上</a>）（<a href="http://blog.csdn.net/haoel/article/details/3081385">下</a>）》，或是《<a href="http://blog.csdn.net/haoel/article/details/1388498">C&#x2F;C++返回内部静态成员的陷阱</a>》那就非常不错了）</li><li>然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。</li><li>实践任务：<ul><li>用C++实现一个BigInt，支持128位的整形的加减乘除的操作。</li><li>用C++封装一个数据结构的容量，比如hash table。</li><li>用C++封装并实现一个智能指针（一定要使用模板）。</li></ul></li><li>《<a href="http://product.china-pub.com/25961">设计模式</a>》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《<a href="http://product.china-pub.com/27862">深入浅出设计模式</a>》）</li><li>实践任务：<ul><li>使用工厂模式实现一个内存池。</li><li>使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。</li><li>使用命令模式实现一个命令行计算器，并支持undo和redo。</li><li>使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。</li></ul></li><li>学习STL的用法和其设计概念  – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。</li><li>实践任务：尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能<ul><li>做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。</li><li>做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。</li></ul></li><li>学习C++的一些类库的设计，如： MFC（看看候捷老师的《<a href="http://product.china-pub.com/3565">深入浅出MFC</a>》） ，Boost, ACE,  CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《<a href="http://blog.csdn.net/haoel/article/details/24058">STL string类的写时拷贝技术</a>》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）</li><li>Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看<a href="http://coolshell.cn/articles/3320.html">Java中的设计模式</a>）。</li><li>推荐阅读《<a href="http://product.china-pub.com/195040">Effective Java</a>》 and 《<a href="http://product.china-pub.com/197212">Java解惑</a>》</li><li>学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。</li><li>Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。</li><li>学习使用Java做Web Service （<a href="http://download.oracle.com/docs/cd/E17802_01/webservices/webservices/docs/2.0/tutorial/doc/">官方教程在这里</a>）</li><li>实践任务： 尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。</li></ul><p>C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是：</p><ul><li>深究C++（我深究C&#x2F;C++了十来年了）</li><li>学习Java的各种设计模式。</li></ul><p>2、加强系统了解</p><p>重要阅读下面的几本书：</p><ul><li>《<a href="http://product.china-pub.com/197413">Unix编程艺术</a>》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。</li><li>《<a href="http://product.china-pub.com/196770">Unix网络编程卷1，套接字</a>》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select&#x2F;poll&#x2F;epoll的差别。</li><li>《<a href="http://product.china-pub.com/35">TCP&#x2F;IP详解 卷1:协议</a>》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP&#x2F;IP的协议，运作原理以及如何TCP的调优。</li><li>实践任务：<ul><li>理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。</li><li>写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。</li><li>写一个简易的HTTP服务器。</li></ul></li><li>《<a href="http://product.china-pub.com/196859">Unix网络编程卷2，进程间通信</a>》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。</li><li>实践任务：<ul><li>主要实践各种IPC进程序通信的方法。</li><li>尝试写一个管道程序，父子进程通过管道交换数据。</li><li>尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。</li></ul></li><li>学习《<a href="http://product.china-pub.com/209058">Windows核心编程</a>》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event,  信号量，互斥量）、异步I&#x2F;O，内存管理，DLL，这几大块搞精通。</li><li>实践任务：使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。</li><li>有了多线程、多进程通信，TCP&#x2F;IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）</li><li>实践任务：通过以上的所有知识，尝试<ul><li>写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I&#x2F;O和网络I&#x2F;O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）</li><li>了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。</li></ul></li></ul><p>3、系统架构</p><ul><li>负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些<a href="http://scholar.google.com.hk/scholar?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&hl=zh-CN&as_sdt=0&as_vis=1&oi=scholart">关于负载均衡的文章</a>读读）</li><li>多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。</li><li><a href="http://en.wikipedia.org/wiki/Content_delivery_network">CDN系统</a> – 就近访问，内容边缘化。</li><li><a href="http://en.wikipedia.org/wiki/Peer-to-peer">P2P式系统</a>，研究一下BT和电驴的算法。比如：<a href="http://en.wikipedia.org/wiki/Distributed_hash_table">DHT算法</a>。</li><li>服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。</li><li><a href="http://en.wikipedia.org/wiki/Virtualization">虚拟化技术</a>，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。</li><li>学习<a href="http://thrift.apache.org/">Thrift</a>，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。</li><li>学习<a href="http://hadoop.apache.org/">Hadoop</a>。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。</li><li>了解<a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL数据库</a>（有人说可能是一个<a href="http://coolshell.cn/articles/3609.html">过渡炒作的技术</a>），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。</li></ul><p>写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。不过，一定有漏的，也有不对的，还希望大家补充和更正。（我会根据大家的反馈随时更新此文）欢迎大家通过我的微博（<a href="http://weibo.com/haoel">@左耳朵耗子</a>）和twitter（@<a href="http://twitter.com/haoel">haoel</a>）和我交流。</p><p>转载自：<a href="http://www.oschina.net/news/19857/programmer-level">http://www.oschina.net/news/19857/programmer-level</a></p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>c</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
      <category>crawler</category>
      
      <category>programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算基本操作知识小结</title>
    <link href="/2018/02/11/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    <url>/2018/02/11/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-左移操作"><a href="#1-左移操作" class="headerlink" title="1.左移操作"></a>1.左移操作</h2><p>a&lt;&lt;b将A的二进制表示的每一位向左移B位，左边超出的位截掉，右边不足的位补0</p><p>A &#x3D; 1100</p><p>B &#x3D; 2</p><p>A &lt;&lt; B &#x3D; 110000</p><h2 id="2-右移操作"><a href="#2-右移操作" class="headerlink" title="2.右移操作"></a>2.右移操作</h2><p>A&gt;&gt; B , 右移操作分为算数右移和逻辑右移</p><p>算术右移是带符号的右移，逻辑右移是不带符号的右移。</p><p>算术右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数。</p><p>逻辑右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0。</p><p>C语言中只有逻辑右移 A &gt;&gt; B</p><p>A &#x3D; 11111111111111111111111110000001</p><p>B &#x3D; 2</p><p>A &gt;&gt; B &#x3D;00111111111111111111111111100000</p><h2 id="3-按位与操作"><a href="#3-按位与操作" class="headerlink" title="3.按位与操作"></a>3.按位与操作</h2><p>a | b将A和B的二进制表示的每一位进行与操作，只有两个对应的二进制位都为1时，结果位才为1，否则为0.</p><p>A &#x3D; 001010</p><p>B &#x3D; 101100</p><p>则：A | B &#x3D; 001000</p><h2 id="4-按位或操作"><a href="#4-按位或操作" class="headerlink" title="4.按位或操作"></a>4.按位或操作</h2><p>a | b将A和B的二进制表示的每一位进行或操作，只要两个对应的二进制位有一个为1，结果位就为1，否则为0.</p><p>A &#x3D; 001010</p><p>B &#x3D; 101100</p><p>A | B &#x3D; 101110</p><h2 id="5-按位非操作"><a href="#5-按位非操作" class="headerlink" title="5.按位非操作"></a>5.按位非操作</h2><p>~ a将A的二进制表示每一位进行取反操作，如果对应的二进制位为0，结果位为1，否则为0.</p><p>A &#x3D; 00000000000000000000000000001010</p><p>则~A &#x3D; 11111111111111111111111111110101</p><h2 id="6-按位异或操作"><a href="#6-按位异或操作" class="headerlink" title="6.按位异或操作"></a>6.按位异或操作</h2><p>a ^ b将A和B的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果位为1，否则为0.</p><p>A &#x3D; 001010</p><p>B &#x3D; 101100</p><p>A ^ B &#x3D; 100110</p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>embed</category>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>位操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7 安装python3</title>
    <link href="/2018/02/10/centos7-%E5%AE%89%E8%A3%85python3/"/>
    <url>/2018/02/10/centos7-%E5%AE%89%E8%A3%85python3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查看当前python版本"><a href="#1-查看当前python版本" class="headerlink" title="1.查看当前python版本"></a>1.查看当前python版本</h2><p>首先使用 python -V 命令查看一下是否安装Python</p><p>which python 查看一下Python可执行文件的位置</p><h2 id="2-安装python"><a href="#2-安装python" class="headerlink" title="2.安装python"></a>2.安装python</h2><p>首先安装依赖包</p><p>yum -y groupinstall “Development tools”</p><h2 id="3-下载python"><a href="#3-下载python" class="headerlink" title="3.下载python"></a>3.下载python</h2><p>wget <a href="https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz">https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</a></p><h2 id="4-解压"><a href="#4-解压" class="headerlink" title="4.解压"></a>4.解压</h2><p>tar -xvJf  Python-3.6.2.tar.xz</p><h2 id="5-切换进入"><a href="#5-切换进入" class="headerlink" title="5.切换进入"></a>5.切换进入</h2><p>cd Python-3.6.2</p><h2 id="6-编译安装"><a href="#6-编译安装" class="headerlink" title="6.编译安装"></a>6.编译安装</h2><p>.&#x2F;configure prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3</p><p><img src="/images/img_5a7ee509c91af.png"></p><p>make &amp;&amp; make install</p><h2 id="7-安装完毕"><a href="#7-安装完毕" class="headerlink" title="7.安装完毕"></a>7.安装完毕</h2><p>&#x2F;usr&#x2F;local&#x2F;目录下就会有python3了</p><h2 id="8-创建软链接"><a href="#8-创建软链接" class="headerlink" title="8.创建软链接"></a>8.创建软链接</h2><p>ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</p><p>ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3</p><h2 id="9-完成"><a href="#9-完成" class="headerlink" title="9.完成"></a>9.完成</h2><p>以后需要使用python2版本，直接调用python</p><p>使用python3版本可以调用python3</p>]]></content>
    
    
    <categories>
      
      <category>crawler</category>
      
      <category>programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python2和python3除法区别</title>
    <link href="/2018/02/09/python2%E5%92%8Cpython3%E9%99%A4%E6%B3%95%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/02/09/python2%E5%92%8Cpython3%E9%99%A4%E6%B3%95%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在Python2中，除法的取值结果取整数</p><p>如9&#x2F;2&#x3D;4</p><p>而在Python3中，除法&#x2F;的结果包含小数，如果只想取整数需要使用&#x2F;&#x2F;运算符</p><p>而如果直接计算9&#x2F;2&#x3D;4.5</p><p>需要计算 9&#x2F;&#x2F;2&#x3D;4</p><p>如果在python2中需要实现与python3相同功能的除法，需要导入模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markup">atime@atime:~$ python -V<br>Python 2.7.12 (default, Jan 19 2018, 16:48:10) <br>Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.<br>&gt;&gt;&gt; from __future__ import division<br>&gt;&gt;&gt; 9/2<br>4.5<br></code></pre></td></tr></table></figure><p> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markup">atime@atime:~$ python -V<br>Python 3.6 (default, Jan 19 2018, 16:49:14) <br>Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.<br> &gt;&gt;&gt; 9/2 4.5<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>crawler</category>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫走进网易热评</title>
    <link href="/2018/02/08/python%E7%88%AC%E8%99%AB%E8%B5%B0%E8%BF%9B%E7%BD%91%E6%98%93%E7%83%AD%E8%AF%84/"/>
    <url>/2018/02/08/python%E7%88%AC%E8%99%AB%E8%B5%B0%E8%BF%9B%E7%BD%91%E6%98%93%E7%83%AD%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<h2 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a><strong>理论分析</strong></h2><p>主要工作：获取网页中的歌曲信息，并将对应的歌曲热门评论数据保存下来。因此主要需要如下信息：歌曲名称、歌手名称、评论信息。获取到这些信息后需要存储数据。</p><p>根据这些需求分析，首先需要一个网络请求库，这里采用requests库来完成。获取到的数据html文档、json文档两种格式，如图1图2所示。对于处理html文档可以使用正则表达式来处理，对于json数据可以由Python自带的json库处理。由于json文件的获取需要一个加密数据，因此需要安装AES加密功能。</p><p><img src="/images/img_5a7c01fa52e36.png"></p><p>图1 获取到的HTML文档</p><p><img src="/images/img_5a7c01fa52e36.png"></p><p>图2 获取到的JSON文档</p><p>    获取到的数据需要保存为更利于观看的图文，因此这里采用将文本文档转化为markdown文件的形式，这样生成的文件在未渲染时文本依旧有很好的可读性，在渲染后可保证多个文档的样式一致性。</p><h2 id="实施方法"><a href="#实施方法" class="headerlink" title="实施方法"></a><strong>实施方法</strong></h2><p>在程序最开始需要先导入如下库：re，json，base64，codecs，requests，如图3所示。通过这些库可以实现网络请求的发送接收，数据的处理，加密数据的计算。为了处理一些网络异常，防止因为网络状况问题导致程序崩溃，这里将requests库里的异常处理功能导入。这样，当网络请求出现异常时，程序会跳转到异常处理部分，发出网络问题的提示，保证程序不会中断执行。</p><p><img src="/images/img_5a7c0204858d1.png"></p><p>图3 导入需要的函数库</p><p>    整个程序的运行流程如图4所示，程序开始运行后首先读取待爬取列表，将列表中的每一个网址依次进行如下处理。首先根据网址信息获取到歌曲ID，根据得到的歌曲ID作为参数构造请求获取HTML文档，然后从HTML文档中获取网页标题信息，完成歌曲名称的爬取。再将歌曲ID作为参数构造请求来获取评论信息。当歌曲信息评论信息获取完毕后将所需的数据保存到文本文档中完成当前网页的爬取。程序将判断是否爬取完成所有的网址，如果所有网址都爬取完成后程序结束。</p><p>对于一些异常情况，本程序也有相应的处理机制。程序中主要处理两类异常情况：网络请求异常和文件读写异常。Python的异常处理能力是很强大的，可向用户准确反馈出错信息。一旦引发而且没有捕捉异常，程序执行就会终止运行。对于网络异常，通常通过重试请求即可得到正确的结果，而不需要终止整个程序的运行，需要处理网络异常，使得程序能够在出错时重试请求。对于文件读写异常，可能重试读写文件也不会成功，这时就需要向用户报告问题。</p><p>发生异常时，Python能“记住”引发的异常以及程序的当前状态。Python还维护着traceback对象，其中含有异常发生时与函数调用堆栈有关的信息。异常可能在一系列嵌套较深的函数调用中引发。程序调用每个函数时，Python会在“函数调用堆栈”的起始处插入函数名。一旦异常被引发，Python会搜索一个相应的异常处理程序。如果当前函数中没有异常处理程序，当前函数会终止执行，Python会搜索当前函数的调用函数，并以此类推，直到发现匹配的异常处理程序，或者Python抵达主程序为止。这一查找合适的异常处理程序的过程就称为“堆栈辗转开解”（Stack Unwinding）。解释器一方面维护着与放置堆栈中的函数有关的信息，另一方面也维护着与已从堆栈中“辗转开解”的函数有关的信息。通过这套成熟的机制可以保证整个程序运行的稳定性，确保得到的数据准确可靠。</p><p><img src="/images/img_5a7c021378a30.png"></p><p>图4 程序运行流程</p><p> </p><p>对于一个网页首先将网址中的歌曲ID通过正则表达式筛选出来，如图5所示，函数将传入的网址通过正则表达式筛选出歌曲ID信息。根据获取的ID信息构造网络请求并发送网络请求，可以将所需的网页HTML文档获取到并保存到程序设置的指定变量内。</p><p><img src="/images/img_5a7c021378a30.png"></p><p>图5 获取歌曲ID</p><p>    如图6所示，程序将网址作为输入，函数返回获取到的HTML文档返回。然后程序将文档通过正则表达式将需要的信息提取出来。提取得到的数据将会以返回值的形式返回。通过这样的设计可以更加高效的获取网页内容，使得整体程序效率大大提高。</p><p><img src="/images/img_5a7c021a860aa.png"></p><p>图6 获取歌曲title标签</p><p>    获取到标题后可以进一步构造请求，把歌曲对应的评论信息爬取到本地，如图7所示，函数首先计算请求地址，构造请求header，将请求的数据 post_data里，完成整个网络请求信息的构造。然后使用requests库提供的post方法执行网络请求，并将获取到的json数据返回。这个函数应用了异常处理，可以保证在网络通信出现故障时程序不崩溃导致整个爬取信息的丢失。</p><p><img src="/images/img_5a7c02234bb12.png"></p><p>图7 获取评论信息</p><p>获取到的数据只存在于程序运行过程中，因此需要对数据进行保存。这里采用将信息输出到markdown文件的形式保存下来。Markdown文件具有可读性好、排版简洁明了的特点，同时它比纯文本更具表现力。</p><h2 id="软件运行结果"><a href="#软件运行结果" class="headerlink" title="软件运行结果"></a><strong>软件运行结果</strong></h2><p>程序中以对4首歌的爬取为例，分别爬取如下网页：</p><p><img src="/images/img_5a7c02d6b6393.png"></p><p>图8 待爬取网页列表</p><p>    爬取过程中程序实时输出爬取进度，如图9所示，对比网页上的评论数目可以初步确定数据是有效的。</p><p><img src="/images/img_5a7c02e14123d.png"></p><p>图9 爬取过程程序输出</p><p>    程序运行完成后生成markdown文件，将markdown文件通过马克飞象工具生成PDF文档。</p><h2 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*- </span><br><span class="hljs-comment"># @Author   : ATIME</span><br><span class="hljs-comment"># @License  : GNU General Public License</span><br><span class="hljs-comment"># @Contact  : atime2008@atime.org.cn   </span><br><span class="hljs-comment"># @Time     : 2017/11/21 10:33</span><br><span class="hljs-comment"># @File     : wyyyy.py</span><br><span class="hljs-comment"># @Version  : Python3.6</span><br><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">from</span> requests.exceptions <span class="hljs-keyword">import</span> RequestException<br><br><br>FILE_NAME = <span class="hljs-string">&#x27;wyyyy.md&#x27;</span><br>URL163 = [<span class="hljs-string">&#x27;http://music.163.com/#/song?id=186001&#x27;</span>,<br>          <span class="hljs-string">&#x27;http://music.163.com/#/song?id=437250607&#x27;</span>,<br>          <span class="hljs-string">&#x27;http://music.163.com/#/song?id=4172700&#x27;</span>,<br>          <span class="hljs-string">&#x27;http://music.163.com/#/song?id=30953009&#x27;</span><br>          ]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Netease</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># self.first_param = &quot;&#123;rid:\&quot;\&quot;, offset:\&quot;0\&quot;, total:\&quot;true\&quot;, limit:\&quot;20\&quot;, csrf_token:\&quot;\&quot;&#125;&quot;</span><br>        <span class="hljs-comment"># self.second_param = &quot;010001&quot;</span><br>        <span class="hljs-comment"># self.third_param = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span><br>        <span class="hljs-comment"># self.forth_param = &quot;0CoJUm6Qyw8W8jud&quot;</span><br>        <span class="hljs-comment"># self.csrf_token = &#x27;1c51dc5cedf74268eaedb744f431f27b&#x27;</span><br>        self.header = &#123;<br>            <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&#x27;http://music.163.com/&#x27;</span>,<br>            <span class="hljs-string">&#x27;Cookie&#x27;</span>: <span class="hljs-string">&#x27;appver=1.5.0.75771;&#x27;</span>,<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&#x27;</span>,<br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_id</span>(<span class="hljs-params">self, url</span>):<br>        pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\d+\d&#x27;</span>, re.S)<br>        song_id = re.findall(pattern, url)<br>        <span class="hljs-keyword">return</span> song_id[<span class="hljs-number">1</span>]  <span class="hljs-comment"># str类型</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_html</span>(<span class="hljs-params">self, url</span>):<br>        request_url = <span class="hljs-string">&#x27;http://music.163.com/song?id=&#x27;</span> + self.get_id(url)<br>        headers = self.header<br>        <span class="hljs-keyword">try</span>:<br>            response = requests.get(request_url, headers=headers)<br>            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-keyword">return</span> response.text<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">except</span> RequestException:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_title</span>(<span class="hljs-params">self, url</span>):<br>        title_html = self.get_html(url)<br>        pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;(?&lt;=title\&gt;).*(?=&lt;/title)&#x27;</span>, re.S)<br>        title = re.findall(pattern, title_html)<br>        title[<span class="hljs-number">0</span>].encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-keyword">return</span> title[<span class="hljs-number">0</span>]  <span class="hljs-comment"># str类型</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">AES_encrypt</span>(<span class="hljs-params">self, text, key, iv</span>):<br>        pad = <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(text) % <span class="hljs-number">16</span><br>        text = text + <span class="hljs-built_in">chr</span>(pad) * pad<br>        encryptor = AES.new(key, AES.MODE_CBC, iv)<br>        encrypt_text = encryptor.encrypt(text)<br>        encrypt_text = base64.b64encode(encrypt_text)<br>        <span class="hljs-keyword">return</span> encrypt_text<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_params</span>(<span class="hljs-params">self</span>):<br>        iv = <span class="hljs-string">&quot;0102030405060708&quot;</span><br>        first_param = <span class="hljs-string">&quot;&#123;rid:\&quot;\&quot;, offset:\&quot;0\&quot;, total:\&quot;true\&quot;, limit:\&quot;20\&quot;, csrf_token:\&quot;\&quot;&#125;&quot;</span><br>        <span class="hljs-comment"># second_param = &quot;010001&quot;</span><br>        <span class="hljs-comment"># third_param = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;</span><br>        forth_param = <span class="hljs-string">&quot;0CoJUm6Qyw8W8jud&quot;</span><br>        first_key = forth_param<br>        second_key = <span class="hljs-number">16</span> * <span class="hljs-string">&#x27;F&#x27;</span><br>        h_encText = self.AES_encrypt(first_param, first_key, iv)<br>        h_encText = self.AES_encrypt(h_encText, second_key, iv)<br>        <span class="hljs-keyword">return</span> h_encText<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_csrf_token</span>(<span class="hljs-params">self</span>):<br>        csrf_token = <span class="hljs-string">&#x27;1c51dc5cedf74268eaedb744f431f27b&#x27;</span><br>        <span class="hljs-keyword">return</span> csrf_token<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_encSecKey</span>(<span class="hljs-params">self</span>):<br>        encSecKey = <span class="hljs-string">&quot;257348aecb5e556c066de214e531faadd1c55d814f9be95fd06d6bff9f4c7a41f831f6394d5a3fd2e3881736d94a02ca919d952872e7d0a50ebfa1769a7a62d512f5f1ca21aec60bc3819a9c3ffca5eca9a0dba6d6f7249b06f5965ecfff3695b54e1c28f3f624750ed39e7de08fc8493242e26dbc4484a01c76f739e135637c&quot;</span><br>        <span class="hljs-keyword">return</span> encSecKey<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_json</span>(<span class="hljs-params">self, song_id, csrf_token, params, encSecKey</span>):<br>        base_url = <span class="hljs-string">&#x27;http://music.163.com/weapi/v1/resource/comments/R_SO_4_&#x27;</span><br>        request_url = base_url + song_id + <span class="hljs-string">&#x27;?csrf_token=&#x27;</span> + csrf_token<br>        headers = self.header<br>        post_data = &#123;<br>            <span class="hljs-string">&quot;params&quot;</span>: params,<br>            <span class="hljs-string">&quot;encSecKey&quot;</span>: encSecKey<br>        &#125;<br>        <span class="hljs-keyword">try</span>:<br>            response = requests.post(request_url, headers=headers, data=post_data)<br>            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-keyword">return</span> response.json()  <span class="hljs-comment"># .content#.decode(&#x27;utf-8&#x27;)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">except</span> RequestException:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_as_json</span>(<span class="hljs-params">self, song_name, json_result</span>):<br>        <span class="hljs-comment"># print(json_result)</span><br>        line = json.dumps(json_result, ensure_ascii=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># print(line)</span><br>        <span class="hljs-comment"># print(type(line))</span><br>        file_name = song_name + <span class="hljs-string">&#x27;.json&#x27;</span><br>        <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># 写入Unicode字符</span><br>            fp.write(line)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_title</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> FILE_NAME<br>        <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(FILE_NAME, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># 写入Unicode字符</span><br>            fp.write(<span class="hljs-string">u&#x27;## 网易云音乐热门评论&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_title</span>(<span class="hljs-params">self, song_name</span>):<br>        <span class="hljs-keyword">global</span> FILE_NAME<br>        <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(FILE_NAME, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># 写入Unicode字符</span><br>            fp.write(<span class="hljs-string">&#x27;\n### &#x27;</span>)<br>            fp.write(song_name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_comment</span>(<span class="hljs-params">self, json_data</span>):<br>        <span class="hljs-keyword">global</span> FILE_NAME<br>        hot_comment = json_data[<span class="hljs-string">&#x27;hotComments&#x27;</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;total:&quot;</span>, <span class="hljs-built_in">len</span>(hot_comment))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(hot_comment)):<br>            <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(FILE_NAME, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># 写入Unicode字符</span><br>                fp.write(<span class="hljs-string">&#x27;\n@( &#x27;</span>)<br>                fp.write(hot_comment[i][<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;nickname&#x27;</span>])<br>                fp.write(<span class="hljs-string">&#x27; )&#x27;</span>)<br>            <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(FILE_NAME, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># 写入Unicode字符</span><br>                fp.write(<span class="hljs-string">&#x27;\n&gt; &#x27;</span>)<br>                fp.write(hot_comment[i][<span class="hljs-string">&#x27;content&#x27;</span>])<br>                fp.write(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                <span class="hljs-comment"># print(hot_comment[i][&#x27;user&#x27;][&#x27;nickname&#x27;])</span><br>                <span class="hljs-comment"># print(hot_comment[i][&#x27;content&#x27;])</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">claw</span>(<span class="hljs-params">self, url_list</span>):<br>        self.set_title()<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> url_list:<br>            song_id = self.get_id(url)<br>            song_name = self.get_title(url)<br>            self.save_title(song_name)<br>            <span class="hljs-built_in">print</span>(song_name)<br>            csrf_token = self.get_csrf_token()<br>            params = self.get_params()<br>            encSecKey = self.get_encSecKey()<br>            json_data = self.get_json(song_id, csrf_token, params, encSecKey)<br>            self.save_comment(json_data)<br>            self.save_as_json(song_id, json_data)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    netease = Netease()<br>    netease.claw(URL163)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>crawler</category>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WordPress 文件结构</title>
    <link href="/2018/02/08/wordpress-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2018/02/08/wordpress-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>根目录</p><p>|-wp-admin</p><p>| |-css</p><p>| |-images</p><p>| |-includes</p><p>| |-js</p><p>| |-maint</p><p>| |-network</p><p>| |-user</p><p>|-wp-content</p><p>| |-languages</p><p>| |-plugins</p><p>| |-themes</p><p>| |-upgrade</p><p>|-wp-includes</p><p>| |-certificates</p><p>| |-css</p><p>| |-fonts</p><p>| |-ID3</p><p>| |-images</p><p>| |-js</p><p>| |-pomo</p><p>| |-SimplePie</p><p>| |-Text</p><p>| |-theme-compat</p><p>**********</p><p><strong>根目录</strong></p><p>**********</p><p>1.index.php：wordpress核心索引文件，即博客输出文件。</p><p>2.license.txt：WordPress GPL许可证文件。</p><p>3.my-hacks.php：定义了博客输出之前处理的追加程序。默认安装中并没有这个文件，但如果存在，它就会被管理页面引用。</p><p>4.readme.html：WordPress安装导言。</p><p>5.wp-atom.php：输出Atom信息聚合内容。</p><p>6.wp-blog-header.php：根据博客参数定义博客页面显示内容。</p><p>7.wp-cron.php</p><p>8.wp-comments-post.php：接收评论，并把其添加到数据库。</p><p>9.wp-commentsrss2.php：用来生成日志评论的RSS2信息聚合内容。</p><p>10.wp-config-sample.php：把WordPress连接到MySQL数据库的示例配置文件。</p><p>11.wp-config.php：这是真正把WordPress连接到MySQL数据库的配置文件。默认安装中虽不包括它，但由于WordPress运行需要这一文件，因此，用户需要编辑这个文件以更改相关设置。</p><p>12.wp-feed.php：根据请求定义feed类型并其返回feed请求文件。</p><p>13.wp-links-opml.php：生成OPML格式的链接(通过WordPress管理菜单添加）列表。</p><p>14.wp-login.php：定义注册用户的登陆页面。</p><p>15.wp-mail.php：用来获取通过邮件提交的博文。这个文件的URL通常被添加到cron任务中，这样cron就会定期检索文件并接收邮件日志。</p><p>16.wp-pass.php：审核受密码保护文章的密码并显示被保护文章。</p><p>17.wp-rdf.php：生成RDF信息聚合内容。</p><p>18.wp-register.php：允许新用户通过联机表单注册用户名。</p><p>19.wp-rss.php：生成RSS信息聚合内容。</p><p>20.wp-rss2.php：生成RSS2信息聚合内容。</p><p>21.wp-settings.php：运行执行前的例行程序，包括检查安装是否正确，使用辅助函数，应用用户插件，初始化执行计时器等等。</p><p>22.wp-trackback.php：处理trackback请求。</p><p>23.wp.php：显示博客日志的简单模板。并没有什么神奇之处，但包括了部分index.php内容。</p><p>24.xmlrpc.php：处理xmlrpc请求。用户无需通过内置的网络管理界面就可发布文章。</p><p>**********</p><p><strong>wp-admin</strong></p><p>**********</p><p>1.wp-admin&#x2F;admin.php：管理文件的核心文件。用来连接数据库，整合动态菜单数据，显示非核心控制页面等。</p><p>2.wp-admin&#x2F;admin-db.php</p><p>3.wp-admin&#x2F;admin-footer.php：定义所有管理控制台的页脚。</p><p>4.wp-admin&#x2F;admin-functions.php：定义了管理控制台使用的多种函数。 5.wp-admin&#x2F;admin- header.php：定义了管理控制台的上半部分内容，包括菜单逻辑 （menu logic）的 menu-header.php文件。</p><p>6.wp-admin&#x2F;bookmarklet.php：使用书签功能时，定义弹出页面。撰写日志时使用默认的edit-form.php文件。</p><p>7.wp-admin&#x2F;categories.php：定义管理页面的类别管理。参考: Manage – Categories</p><p>8.wp-admin&#x2F;cat-js.php</p><p>9.wp-admin&#x2F;edit.php：定义管理页面的日志管理。参考:  Manage – Posts</p><p>10.wp-admin&#x2F;edit-comments.php：定义管理页面的评论管理。参考:  Manage – Comments</p><p>11.wp-admin&#x2F;edit-form-advanced.php：定义管理页面的日志高级编辑形式管理，包括post.php。参考:  Write – Write Post – Advanced</p><p>12.wp-admin&#x2F;edit-form.php：定义管理页面的日志简单编辑形式管理，包括post.php。参考:  Write – Write Post</p><p>13.wp-admin&#x2F;edit-form-comment.php：编辑特定日志评论。</p><p>14.wp-admin&#x2F;edit-form-ajax-cat.php</p><p>15.wp-admin&#x2F;edit-link-form.php</p><p>16.wp-admin&#x2F;edit-page-form.php：定义管理模块页面的页面编辑，包括post.php和page-new.php。参考: Write – Write Page</p><p>17.wp-admin&#x2F;edit-pages.php：定义管理模块页面的页面管理。参考:  Manage – Pages</p><p>18.wp-admin&#x2F;execute-pings.php</p><p>19.wp-admin&#x2F;import.php</p><p>20.wp-admin&#x2F;index.php：默认管理页面。根据用户请求显示相应的页面。</p><p>21.wp-admin&#x2F;inline-uploading.php</p><p>22.wp-admin&#x2F;install-helper.php：定义数据库维护函数，包括popular-in-plugins maybe_create_table() 和maybe_add_column()。</p><p>23.wp-admin&#x2F;install.php：安装WordPress。</p><p>24.wp-admin&#x2F;link-add.php：链接添加。参考:  Links – Add Link</p><p>25.wp-admin&#x2F;link-categories.php：链接分类管理。参考: Links – Link Categories</p><p>26.wp-admin&#x2F;link-import.php：导入链接。参考: Links – Import Links</p><p>27.wp-admin&#x2F;link-manager.php：链接管理。参考:  Links – Manage Links</p><p>28.wp-admin&#x2F;link-parse-opml.ph：导入链接时，用来解析OPML文件。</p><p>29.wp-admin&#x2F;list-manipulation.js</p><p>30.wp-admin&#x2F;list-manipulation.php</p><p>31.wp-admin&#x2F;menu-header.php：用于在管理界面显示菜单。</p><p>32.wp-admin&#x2F;menu.php：定义了默认管理菜单结构。</p><p>33.wp-admin&#x2F;moderation.php：定义了评论审核函数。</p><p>34.wp-admin&#x2F;options.php：升级后，用来更改所有设置。</p><p>35.wp-admin&#x2F;options-discussion.php：管理评论和trackback相关选项。参考:  Options – Discussion</p><p>36.wp-admin&#x2F;options-general.php：管理基本配置选项。参考: Options – General</p><p>37.wp-admin&#x2F;options-head.php</p><p>38.wp-admin&#x2F;options-misc.php：设置文件上传，链接跟踪，自定义”hacks”等相关选项。参考：Options – Miscellaneous</p><p>39.wp-admin&#x2F;options-permalink.php：管理永久链接选项。参考: Options – Permalinks</p><p>40.wp-admin&#x2F;options-reading.php：设置如何把网站信息发送到读者浏览器或其它应用程序。参考: Options – Reading</p><p>41.wp-admin&#x2F;options-writing.php：管理日志撰写界面。参考:Options – Writing</p><p>42.wp-admin&#x2F;page-new.php：创建新页面。</p><p>43.wp-admin&#x2F;plugin-editor.php：编辑插件文件。</p><p>44.wp-admin&#x2F;plugins.php：管理插件。</p><p>45.wp-admin&#x2F;post.php：创建新日志。</p><p>46.wp-admin&#x2F;profile-update.php</p><p>47.wp-admin&#x2F;profile.php：管理个人资料或配置。</p><p>48.wp-admin&#x2F;setup-config.php：安装时，用来创建wp-config.php文件。</p><p>49.wp-admin&#x2F;sidebar.php</p><p>50.wp-admin&#x2F;templates.php：编辑服务器可写文件。</p><p>51.wp-admin&#x2F;theme-editor.php：编辑特定主题中的文件。</p><p>52.wp-admin&#x2F;themes.php：管理主题。</p><p>53.wp-admin&#x2F;update-links.php</p><p>54.wp-admin&#x2F;upgrade-functions.php：定义了版本升级函数。</p><p>55.wp-admin&#x2F;upgrade-schema.php：定义了升级中使用的默认表格结构和选项。</p><p>56.wp-admin&#x2F;upgrade.php：版本升级。</p><p>57.wp-admin&#x2F;user-edit.php：编辑用户。</p><p>58.wp-admin&#x2F;users.php：管理用户。</p><p>59.wp-admin&#x2F;wp-admin.css：定义了管理控制台的默认样式表。</p><p>60.wp-admin&#x2F;xfn.js</p><p>**********</p><p><strong>wp-includes</strong></p><p>**********</p><p>wp-includes目录</p><p>1.wp-includes&#x2F;cache.php</p><p>2.wp-includes&#x2F;capabilities.php</p><p>3.wp-includes&#x2F;class-IXR.php：Incutio XML-RPC库。包括了 XML RPC支持函数。由<a href="http://scripts.incutio.com/xmlrpc/%E6%8F%90%E4%BE%9B%E6%94%AF%E6%8C%81%E3%80%82">http://scripts.incutio.com/xmlrpc/提供支持。</a></p><p>4.wp-includes&#x2F;classes.php：包括了基本的类，如核心文章提取机制WP_Query和改写管理WP_Rewrite。</p><p>5.wp-includes&#x2F;class-pop3.php：包括了支持使用POP邮箱的类。可供wp-mail.php 使用。</p><p>6.wp-includes&#x2F;class-snoopy.php：Snoopy是一个PHP类，用来模仿Web浏览器的功能，它能自动完成检索网页和发送表单的任务。</p><p>7.wp-includes&#x2F;comment-functions.php</p><p>8.wp-includes&#x2F;default-filters.php</p><p>9.wp-includes&#x2F;feed-functions.php</p><p>10.wp-includes&#x2F;functions-compat.php：即新版本PHP中用来支持老版本PHP的函数文件。</p><p>11.wp-includes&#x2F;functions-formatting.php：用于清理XHTML和用特定字符集正确格式化文本。</p><p>12.wp-includes&#x2F;functions-post.php：定义了在数据库中管理日志，查询用户权限，提取和撰写评论等函数。</p><p>13.wp-includes&#x2F;functions.php：包含许多重要的支持函数，它是WordPress中最大的文件，函数数量几乎是第二大文件的两倍。</p><p>14.wp-includes&#x2F;gettext.php：PHP-gettext GPL 翻译库组成部分。</p><p>15.wp-includes&#x2F;kses.php：用来渲染和过滤日志或评论中的HTML。</p><p>16.wp-includes&#x2F;links.php：用来管理和使用WordPress的链接功能。</p><p>17.wp-includes&#x2F;locale.php：用来替代默认的星期和月份值。</p><p>18.wp-includes&#x2F;pluggable-functions.php</p><p>19.wp-includes&#x2F;registration-functions.php</p><p>20.wp-includes&#x2F;rss-functions.php</p><p>21.wp-includes&#x2F;streams.php：定义了包装文件流和字符流的类。</p><p>22.wp-includes&#x2F;template-functions-author.php：包含了与日志作者或评论人相关的主题函数。</p><p>23.wp-includes&#x2F;template-functions-category.php：包含了与类别相关的主题函数。</p><p>24.wp-includes&#x2F;template-functions-comment.php：包含了与评论相关的主题函数。</p><p>25.wp-includes&#x2F;template-functions-general.php：包含了常规主题函数。</p><p>26.wp-includes&#x2F;template-functions-links.php：包含了与链接相关的主题函数。</p><p>27.wp-includes&#x2F;template-functions-post.php：包含了与日志相关的主题函数。</p><p>28.wp-includes&#x2F;template-functions.php：包含了以上所有”template-”文件。</p><p>29.wp-includes&#x2F;template-loader.php</p><p>30.wp-includes&#x2F;vars.php：用来设置杂项变量。</p><p>31.wp-includes&#x2F;version.php：用来设置当前使用的WordPress版本。</p><p>32.wp-includes&#x2F;wp-db.php：包含了用来连接MySQL数据库的函数。</p><p>33.wp-includes&#x2F;wp-l10n.php：提供支持多语言版本的函数。</p><p><img src="/images/img_5a7c2fd6d4797.png"></p>]]></content>
    
    
    <categories>
      
      <category>programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何去除“站长统计”文字链接？</title>
    <link href="/2018/02/08/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E7%AB%99%E9%95%BF%E7%BB%9F%E8%AE%A1%E6%96%87%E5%AD%97%E9%93%BE%E6%8E%A5%EF%BC%9F/"/>
    <url>/2018/02/08/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E7%AB%99%E9%95%BF%E7%BB%9F%E8%AE%A1%E6%96%87%E5%AD%97%E9%93%BE%E6%8E%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>站长统计没有自带隐藏前台“站长统计”文字的功能，这2字在我们页面中时而多余时而碍眼，所以90%以上的用户都会想办法去除或隐藏“站长统计”四个字。</p><p>最常见的是把统计代码放在一个DIV中，然后填写class再用样式块隐藏，还有比较常见的就是直接给div写内嵌样式隐藏整个div然后把统计代码放入div中。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;https://s4.cnzz.com/z_stat.php?id=1258438301&amp;web_id=1258438301&quot;</span> language=<span class="hljs-string">&quot;JavaScript&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>众所周知，使用display:none对搜索引擎来说是不友好的，所以避之为吉，能避免使用就避免使用，因为对于搜索引擎来说可以隐藏有作弊嫌疑。</p><h2 id="获取到的默认代码"><a href="#获取到的默认代码" class="headerlink" title="获取到的默认代码"></a>获取到的默认代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<span class="hljs-keyword">var</span> cnzz_protocol = ((<span class="hljs-string">&quot;https:&quot;</span> == <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">protocol</span>) ? <span class="hljs-string">&quot; https://&quot;</span> : <span class="hljs-string">&quot; http://&quot;</span>);<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-built_in">unescape</span>(<span class="hljs-string">&quot;%3Cspan id=&#x27;cnzz_stat_icon_1258438301&#x27;%3E%3C/span%3E%3Cscript src=&#x27;&quot;</span> + cnzz_protocol + <span class="hljs-string">&quot;s4.cnzz.com/z_stat.php%3Fid%3D1258438301&#x27; type=&#x27;text/javascript&#x27;%3E%3C/script%3E&quot;</span>));&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="/images/img_5a7bfec79c346.png"></p><p>在获取统计代码是我们选择默认代码而不是精简代码，如上图</p><h2 id="修改后的默认代码"><a href="#修改后的默认代码" class="headerlink" title="修改后的默认代码"></a>修改后的默认代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markup">&lt;script type=&quot;text/javascript&quot;&gt;<br>var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan style=&#x27;display:none;&#x27; id=&#x27;cnzz_stat_icon_1258438301&#x27;%3E%3C/span%3E%3Cscript src=&#x27;&quot; + cnzz_protocol + &quot;s5.cnzz.com/stat.php%3Fid%3D1258438301&#x27; type=&#x27;text/javascript&#x27;%3E%3C/script%3E&quot;));<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在document.write(unescape(“%3Cspan与id&#x3D;’cnzz_stat_icon_之间增加style&#x3D;’display:none;’</p><p>或者是直接复制这里修改过的默认代码然后修改ID为你网站的统计ID，有2处要修改，分别是id&#x3D;’cnzz_stat_icon_1258438301’和stat.php%3Fid%3D1258438301，把1258438301修改成你网站的统计id就可以了。</p><p>增加一段js隐藏站长统计文字链接</p><p>在获取的统计代码最后，也就是</script>前面，加一段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;cnzz_stat_icon_1258438301&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;none&quot;</span>;<br></code></pre></td></tr></table></figure><p>在保存前记得修改站点统计ID，将1258438301修改为你的站长统计网站统计ID即可，现在用前面介绍的那种，相比前者比后者更好。</p>]]></content>
    
    
    <categories>
      
      <category>programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>站长统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bilibili分享 -《my heart is open》</title>
    <link href="/2018/02/03/bilibili/"/>
    <url>/2018/02/03/bilibili/</url>
    
    <content type="html"><![CDATA[<p>[bilibili cid&#x3D;“22642679” ]13853665[&#x2F;bilibili]</p>]]></content>
    
    
    <categories>
      
      <category>programming</category>
      
      <category>web</category>
      
      <category>essayist</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bilibili</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之LCD控制器简介</title>
    <link href="/2017/02/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8Blcd%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <url>/2017/02/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8Blcd%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-LCD信号线"><a href="#1-LCD信号线" class="headerlink" title="1.LCD信号线"></a>1.LCD信号线</h2><p>常用的LCD显示屏会有这些信号线：VSYNC：垂直同步信号;</p><p>HSYNC：水平同步信号；</p><p>VCLK：象素时钟信号；</p><p>VD[23:0]：LCD像素数据输出端口；</p><p>VDEN：数据使能信号；</p><p>V+，V-：背光。</p><h2 id="2-LCD使用步骤"><a href="#2-LCD使用步骤" class="headerlink" title="2.LCD使用步骤"></a>2.LCD使用步骤</h2><p>    S3C2440芯片内有一个LCD控制器，专门用于驱动LCD屏幕，因此，在S3C2440上驱动LCD相对容易，只需要设置好相关寄存器即可。使用LCD需一下步骤：</p><ol><li>打开背光。</li><li>LCD时序设置。</li><li>在Frame Buffer中写数据。</li></ol><h2 id="3-调色板"><a href="#3-调色板" class="headerlink" title="3.调色板"></a>3.调色板</h2><p>当Frame buffer和LCD使用的不是数据位数不一致时，需要使用调色板来将颜色数据转换为需要在LCD显示的数据。在不使用调色板时，LCD显示过程是：Frame Buffer中的数据通过LCD控制器的驱动，显示到LCD上。</p><p>当使用调色板时，Frame Buffer上不保存LCD需要现实的实际数据，而是保存需要在LCD显示的颜色索引，通过LCD控制器把索引对应调色板上保存的颜色数据显示到LCD上。</p><h2 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4.示例代码"></a>4.示例代码</h2><p>LCD控制器使用需要几个核心的函数，如引脚的初始化、LCD控制寄存器设置、LCD电源开关。如下所示：</p><p><img src="/images/34335b2c10ad2acb6abb908889e84bef.png"></p><p><img src="/images/a06125e340e9948d181e125f3e2d959c.png"></p><p><img src="/images/7ee745bd4d9fc69d341d4dfec431c225.png"></p><p>在使用时，需要依次执行:</p><p><img src="/images/6817fdfffddd8be8da3d3df6f466e3b4.png"></p><p>便于演示，代码中使用清屏命令来控制LCD的显示颜色，清屏所用代码如下：</p><p><img src="/images/193613db4d90b0ebeb273d0ec8991d1a.png"></p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>lcd控制器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之系统时钟</title>
    <link href="/2017/02/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/"/>
    <url>/2017/02/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-系统时钟"><a href="#1-系统时钟" class="headerlink" title="1.系统时钟"></a>1.系统时钟</h2><p>S3C2440有三种时钟:FCLK(用于CPU核),HCLK(用于主机模块),PCLK(用于外设).两种PLL(锁相环):MPLL(用于设置FCLK，HCLK，PCLK),UPLL(用于设置USB设备)。如图所示：</p><p><img src="/images/018977f07a2dca76c84df9296b618632.png"></p><h2 id="2-系统时钟初始化"><a href="#2-系统时钟初始化" class="headerlink" title="2.系统时钟初始化"></a>2.系统时钟初始化</h2><p>S3c2440系统时钟初始化流程如下：(1) 系统刚上电几毫秒后，FCLK等于外部晶振的振荡频率，即FCLK&#x3D;Fin(2) 当复位信号nReset恢复高电平后，锁相环按照寄存器MPLLCON和CLKDIVN设定的倍频比例开始生成所需要的时钟频率。从锁相环开始工作到输出新的稳定的频率值需要一定的时间(lock time 即锁相环的捕获时间)，经过这段时间后，锁相环输出新的频率值，这是FCLK等于锁相环的输出。</p><p>如图所示：</p><p><img src="/images/5539d3d662d3259d7387130763d39584.png"></p><h2 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="3.代码解析"></a>3.代码解析</h2><p>代码如下所示，首先设置FCLK、MCLK、PCLK的分频比例，随后根据S3C2440的芯片手册说明，当HDIV非1时需要执行一段代码。然后就可以设置MPLLCOM寄存器，设定锁相环输出频率了。</p><p><img src="/images/25eafde205c721af62528c1a00d34ba1.png"></p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>系统时钟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之串口程序</title>
    <link href="/2017/02/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
    <url>/2017/02/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-串口通信"><a href="#1-串口通信" class="headerlink" title="1.串口通信"></a>1.串口通信</h2><p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。在学习单片机时，通常调试程序都需要先将串口程序调试完成，在此基础上，可以在后续调试程序中使用串口打印数据，设置断点。</p><p>嵌入式裸机程序的编写过程中，尤其在没有显示屏幕的情况下，需要串口来配合调试.</p><h2 id="2-S3C2440-UART控制器"><a href="#2-S3C2440-UART控制器" class="headerlink" title="2.S3C2440 UART控制器"></a>2.S3C2440 UART控制器</h2><p>S3C2440 UART控制器，提供了三个独立的异步串行I&#x2F;O端口，每个端口都可以在中断模式或DMA模式下工作。也就是说，S3C2440的 UART可以生成中断或DMA请求用于CPU和UART之间的数据传输。UART串口挂接在APB总线上，APB总线最高可以达到50MHz工作频率，在使用APB时钟频率时可以达到最高115.2Kbps波特率的通信速度。如果UART串口接收外部设备提供外部时钟，UART可以在更高的速度下工作。每个UART串口在接收装置和发送装置里分别包含一个64Byte的FIFO缓冲区，用于缓存发送数据和接收数据。</p><h2 id="3-帧结构"><a href="#3-帧结构" class="headerlink" title="3.帧结构"></a>3.帧结构</h2><p>UART在通信之前要在发送端和接收端约定好帧结构，也就是约定好传输数据帧格式。l  开始位：必须包含在数据帧中，表示一个帧的开始。</p><p>l  数据位：可选5，6，7，8位，该位长度可由编程人员指定。</p><p>l  校验位：如果在开启了数据校验时，该位必须指定。</p><p>l  停止位：可选1，2位，该位长度可由编程人员指定。</p><p>通信双方约定好帧格式后，指定同一波特率，以保证双方数据传输的同步。</p><p><img src="/images/671f14d6dfe2d271d62358790267723c.png"></p><h2 id="4-核心代码"><a href="#4-核心代码" class="headerlink" title="4.核心代码"></a>4.核心代码</h2><p>S3C2440的串口程序核心代码如图所示，最少需要这三个函数：串口初始化，串口发送，串口接收。同单片机一样，串口初始化也就是需要设置IO引脚功能和设置串口的帧结构和串口波特率。</p><p>串口的读写数据都有专用的寄存器负责，使用很简单，从代码中可以看出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化UART0</span><br><span class="hljs-comment"> * 115200,8N1,无流控</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">uart0_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    GPHCON  |= <span class="hljs-number">0xa0</span>;    <span class="hljs-comment">// GPH2,GPH3用作TXD0,RXD0</span><br>    GPHUP   = <span class="hljs-number">0x0c</span>;     <span class="hljs-comment">// GPH2,GPH3内部上拉</span><br><br>    ULCON0  = <span class="hljs-number">0x03</span>;     <span class="hljs-comment">// 8N1(8个数据位，无较验，1个停止位)</span><br>    UCON0   = <span class="hljs-number">0x05</span>;     <span class="hljs-comment">// 查询方式，UART时钟源为PCLK</span><br>    UFCON0  = <span class="hljs-number">0x00</span>;     <span class="hljs-comment">// 不使用FIFO</span><br>    UMCON0  = <span class="hljs-number">0x00</span>;     <span class="hljs-comment">// 不使用流控</span><br>    UBRDIV0 = UART_BRD; <span class="hljs-comment">// 波特率为115200</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送一个字符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c)</span><br>&#123;<br>    <span class="hljs-comment">/* 等待，直到发送缓冲区中的数据已经全部发送出去 */</span><br>    <span class="hljs-keyword">while</span> (!(UTRSTAT0 &amp; TXD0READY));<br>    <br>    <span class="hljs-comment">/* 向UTXH0寄存器中写入数据，UART即自动将它发送出去 */</span><br>    UTXH0 = c;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 接收字符</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 等待，直到接收缓冲区中的有数据 */</span><br>    <span class="hljs-keyword">while</span> (!(UTRSTAT0 &amp; RXD0READY));<br>    <br>    <span class="hljs-comment">/* 直接读取URXH0寄存器，即可获得接收到的数据 */</span><br>    <span class="hljs-keyword">return</span> URXH0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>串口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile入门</title>
    <link href="/2017/02/08/makefile%E5%85%A5%E9%97%A8/"/>
    <url>/2017/02/08/makefile%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>在学习单片机时，经常使用Keil、IAR等IDE工具，在这些IDE工具中建立工程，然后就可以编程、编译、下载到单片机了。但是在嵌入式编程中，通常不会使用这些IDE，而是直接使用交叉编译环境进行编译，使用J-Flash进行下载。</p><p>使用IDE开发好处是不需要处理过多的编译选项，很多IDE会自动生成makefile，自动处理编译链接过程。而嵌入式编程，如果使用交叉编译环境，就需要自己写makefile来完成编译工作。会不会写makefile，也从一个侧面说明了一个人是否具备完成大型工程的能力。</p><p>makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><h2 id="1-编译、链接过程"><a href="#1-编译、链接过程" class="headerlink" title="1.编译、链接过程"></a>1.编译、链接过程</h2><p>C语言中，要将一段代码生成可执行文件，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p><h2 id="2-makefile"><a href="#2-makefile" class="headerlink" title="2.makefile"></a>2.makefile</h2><p>在Linux下，当我们在某个目录使用make命令时，会自动搜索本目录下的makefile文件，根据文件的命令执行。makefile的格式如下：</p><p>target… : prerequisites …</p><p>command</p><p>即：注明生成的目标，冒号后书写生成目标的依赖文件，下一行Tab后写需要执行的命令。若命令过长，可以使用\来换行。</p><p>make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p><h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs := head.o init.o serial.o main.o000.bin: <span class="hljs-variable">$(objs)</span><br>arm-linux-ld -Ttext 0x000000 -o timer_elf <span class="hljs-variable">$^</span><br>arm-linux-objcopy -O binary -S timer_elf <span class="hljs-variable">$@</span><br>arm-linux-objdump -D -m arm timer_elf &gt; timer.dis<br><span class="hljs-section">%.o:%.c</span><br>arm-linux-gcc -Wall -nostdlib -O2 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">%.o:%.S</span><br>arm-linux-gcc -Wall -nostdlib -O2 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">clean:</span><br>rm -f timer.bin timer_elf timer.dis *.o<br></code></pre></td></tr></table></figure><p>第一行定义了一个objs，它是由head.o init.o serial.o main.o四个文件组成。第二行定义了000.bin生成的过程，他的需要有head.o init.o serial.o main.o这四个文件。</p><p>第3~5行说明要执行的指令，根据先后，依次执行。</p><p>第6行定义了一个通用规则，任何.o文件，由.c文件生成所需要的指令。</p><p>第7行将.c文件编译为.o文件的命令。</p><p>第8行义了一个通用规则，任何.o文件，由.s文件生成所需要的指令。</p><p>第9行将.s文件编译为.o文件的命令。</p><p>第10行定义了一个新目标，当执行make clean 时会执行它。</p><p>第11行是make clean所设置要执行的指令，清理生成的文件。</p><p>当执行make命令时，自动会执行生成000.bin文件的过程，当它需要某一个文件时会查找这个文件生成的方法，依次执行。</p><h2 id="4-技巧"><a href="#4-技巧" class="headerlink" title="4.技巧"></a>4.技巧</h2><p>上例中的第1、2行是常用的定义变量使用变量的方法。通过使用变量，可以使makefile在不同工程中做简单的修改即可使用。makefile支持通配符，如*,c代表一系列c文件，%则代表0个或多个字符。</p><p>$^表示一些列相同的命令，所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p><p>$@表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</p><p>$&lt;表示依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;“将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>main函数从哪来？</title>
    <link href="/2017/02/07/main%E5%87%BD%E6%95%B0%E4%BB%8E%E5%93%AA%E6%9D%A5%EF%BC%9F/"/>
    <url>/2017/02/07/main%E5%87%BD%E6%95%B0%E4%BB%8E%E5%93%AA%E6%9D%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>了解C语言的小伙伴，一定会好奇为什么编程都会从main函数开始执行。相信很多学过的人都只是知道一个程序是从main函数这个入口进入的，但main函数又是从哪里来的呢？</p><p>对于在电脑上编程，如在windows&#x2F;Linux上，main函数是由操作系统调用的，main函数完成后，会给操作系统返回值。</p><p>对于最简单的嵌入式程序，CPU从上电开始，需要执行以下步骤：</p><ol><li>从启动文件的代码开始执行程序。</li><li>启动代码跳转到main函数</li><li>main函数结束后返回启动文件也就是说，main函数是由人为设定的，并不一定要叫做main函数。</li></ol><p>启动文件：</p><p>因进入main函数后程序是以C语言编写，C语言中的函数实现需要出入栈，因此启动文件在跳转到main函数前需要先设置栈。完成栈的设置后，启动文件会做一些硬件方面的初始化工作，如内存的初始化。下面将以之前的代码为例进行讲解：</p><p>随后调用main函数，设置main函数的返回地址。</p><p>main函数返回后，启动文件还会进行一些清理工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markup">@******************************************************************************<br>@ File：head.S<br>@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行<br>@******************************************************************************       <br>   <br>.extern     main<br>.text <br>.global _start <br>_start:<br>Reset:                  <br>    ldr sp, =4096           @ 设置栈指针，以下都是C函数，调用前需要设好栈<br>    bl  disable_watch_dog   @ 关闭WATCHDOG，否则CPU会不断重启<br>    // bl是位置无关码，相当于：PCnew = PC + 偏移<br>    //                         PCnew = (4+8) + 0x28 = 0x34<br>    <br>    //ldr pc, =disable_watch_dog  /* 这样写将出错 */<br>    <br>    bl  clock_init          @ 设置MPLL，改变FCLK、HCLK、PCLK<br>    bl  memsetup            @ 设置存储控制器以使用SDRAM<br>    bl  copy_steppingstone_to_sdram     @ 复制代码到SDRAM中<br>    ldr pc, =on_sdram                   @ 跳到SDRAM中继续执行<br>on_sdram:<br>    ldr sp, =0x34000000     @ 设置栈指针<br>    ldr lr, =halt_loop      @ 设置返回地址<br>    ldr pc, =main           @ 调用main函数<br>halt_loop:<br>    b   halt_loop<br></code></pre></td></tr></table></figure><p>这里以SDRAM程序的启动文件为例，程序流程如下：</p><ol><li>关闭看门狗，否则程序会不断重启。</li><li>初始化SDRAM，然后将程序拷贝到SDRAM中执行。</li><li>设置栈指针。</li><li>跳转到main函数。</li><li>设置main函数返回后进入一个死循环，防止程序跑飞。</li></ol>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>main</tag>
      
      <tag>嵌入式</tag>
      
      <tag>底层函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S3C2440两种启动方式介绍</title>
    <link href="/2017/02/06/s3c2440%E4%B8%A4%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <url>/2017/02/06/s3c2440%E4%B8%A4%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>S3C2440处理器通常有两种启动方式，分别为Nor Flash启动和Nand Flash启动，两种启动方式的细节略有不同。</p><h2 id="1-Nand-Flash启动"><a href="#1-Nand-Flash启动" class="headerlink" title="1.Nand Flash启动"></a>1.Nand Flash启动</h2><p>当设置开发板为Nand Flash启动时，开发板将会按一下步骤执行：</p><ol><li>硬件自动将Nand Flash前4k内容拷贝到S3C2440芯片内部的SRAM中，并将SRAM起始地址设置为0x0.</li><li>S3C2440从0x0地址开始执行代码。</li></ol><p>通常在bootloader中，前4k内容为初始化最基础的的设备，并复制后面的内容到SDRAM中，以便于继续执行代码。</p><p><img src="/images/a0a41dc26918a63d7fce8b5a3ccb9943.png"></p><h2 id="2-Nor-Flash启动"><a href="#2-Nor-Flash启动" class="headerlink" title="2.Nor Flash启动"></a>2.Nor Flash启动</h2><p>当S3C2440设置为Nor Flash启动时，CPU会将Nor Flash所在位置指向为0x0地址，然后CPU从0x0开始执行。</p><p>Nor Flash可以像内存一样读数据，但不能像内存一样写数据。</p><p><img src="/images/3c4d23683955ac453c39cefbad627be1.png"></p><p>并不是所有2440开发板都会配有Nand Flash和North Flash，有些会只有Nand Flash。</p><p>Nand Flash相对于Nor Flash拥有更大的存储空间，可以在Nand Flash上烧写更大的程序。而Nor Flash则具有可以像内存一样读取数据的优势。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>nandflash</tag>
      
      <tag>norflash</tag>
      
      <tag>s3c2440</tag>
      
      <tag>启动方式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATIME_MSP430 开发库</title>
    <link href="/2017/02/05/atime_msp430-%E5%BC%80%E5%8F%91%E5%BA%93/"/>
    <url>/2017/02/05/atime_msp430-%E5%BC%80%E5%8F%91%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>对于想要学习嵌入式的小伙伴，如果没有单片机开发经验，会发现嵌入式学习还是很困难的。因此建议在学习嵌入式之前先简单了解一些单片机的知识。</p><p>今天介绍我之前学习单片机总结出的一些东西，也为学习单片机的人提供一个更便捷的学习路线。</p><p>目前函数库使用MSP430F149作为核心，函数库包含部分常用模块的操作函数。该函数库高内聚低耦合，以atime_msp430core.h作为支持，保证其他头文件的正常使用。</p><p>学习中，可以从IO接口的使用开始，紧接着学习串口的使用、中断的使用，完成之后可以学习一些常用的外设，如ADC、LCD屏幕等。在完成这些部分的学习后，基本就有了对单片机的入门认识。</p><p>函数库已经封装好很多外设的函数，在学习MSP430过程中，需要理解函数实现的具体细节，不仅仅是简单的应用。</p><ul><li>    项目主页地址：<a href="http://elevenperfect.github.io/ATIME/_MSP430/">http://elevenperfect.github.io/ATIME\_MSP430/</a></li><li>    项目源码地址：<a href="https://github.com/EleVenPerfect/ATIME/_MSP430">https://github.com/EleVenPerfect/ATIME\_MSP430</a> <img src="/images/post60.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>msp430</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github for windows 简介</title>
    <link href="/2017/02/04/153/"/>
    <url>/2017/02/04/153/</url>
    
    <content type="html"><![CDATA[<p>在写代码调试时，经常会出现之前的代码可以用，但是修改后不知为何又出问题的情况。通常的办法是将可用的代码事先复制一份再进行修改，这样代码的管理并不科学。今天介绍使用Github来进行代码的版本控制，用专业的工具，提高工作效率。</p><p>这里介绍最简单的Github for windows 图形化软件，不需要学习使用各种命令，对于新手更容易入门。</p><h2 id="1-Github是什么"><a href="#1-Github是什么" class="headerlink" title="1.Github是什么"></a>1.Github是什么</h2><p>GitHub 是一个面向开源及私有软件项目的托管平台。</p><p>作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</p><p>GitHub for Windows 是一个 Metro 风格应用程序，集成了自包含版本的 Git，bash 命令行 shell，PowerShell 的 posh-git 扩展。GitHub 为 Windows 用户提供了一个基本的图形前端去处理大部分常用版本控制任务，可以创建版本库，向本地版本库递交补丁，在本地和远程版本库之间同步。微软也通过CodePlex向开发者提供 git 版本控制系统，而 GitHub 创造了一个更具有吸引力的 Windows 版本。</p><h2 id="2-注册Github"><a href="#2-注册Github" class="headerlink" title="2.注册Github"></a>2.注册Github</h2><p>登录网址：<a href="https://github.com/">https://github.com</a></p><p>如图所示，填写你的用户名，电子邮箱，密码即可注册完成。</p><p>点击上栏的加号创建一个程序仓库，用于存放代码。</p><p>点击New repository创建代码仓库:</p><p><img src="/images/b6dc68b1abf9bb70ae07f3bfbe7cec12.png"></p><p>创建完成后，这里介绍windows下不需要使用命令的方式进行代码管理。</p><h2 id="3-配置Github-for-windows"><a href="#3-配置Github-for-windows" class="headerlink" title="3.配置Github for windows"></a>3.配置Github for windows</h2><p>首先去Github for windows网站下载客户端：<a href="https://desktop.github.com/">https://desktop.github.com/</a></p><p>下载到的是一个在线安装器，运行后会 在线下载最新版本的软件进行安装。下载速度很慢，需要耐心等待。</p><p>安装完成后，即需要登陆之前注册的Github账号。登录完如图所示。要查看自己刚刚建立的代码仓库需要手动克隆仓库到本地。</p><p><img src="/images/ca7d7fc2564284b62e015c48d3461c38.png"></p><p>点击左上角加号，选择Clone，将会列出当前帐号的所有代码仓库，选择你的仓库，点击下方的按钮，会提示你要保存到本地的位置。</p><p><img src="/images/acf5faa2d48a9696d412bb55e3c5326e.png"></p><p>随后将会自动同步你的代码仓库到本地。</p><p>本地的文件夹中，编辑修改文件，软件将会自动监控文件变化。</p><p>当你完成一定的修改后，需要保存版本，可以进入Github for windows 。如图所示：</p><p><img src="/images/b818c9c3f2bf3454647278c4e6367017.png"></p><p>填写summary摘要和description说明，然后点击commit to master即可完成一个commit的创建。</p><p>完成一个commit后需要点击右上角的Sync来同步数据到Github网站，这样在不同的地点登陆都可以从网站下载最新的版本。</p><h2 id="4-代码管理"><a href="#4-代码管理" class="headerlink" title="4.代码管理"></a>4.代码管理</h2><p>Github for windows 不仅仅可以提交commit、同步，还可以在你代码出问题是，退回到原来commit的某个时间点。在代码仓库的History中，可以看到自己提交的commit，在这里选择某个commit点击右上方的revert可以恢复。</p><p>除此之外，Github还有跟多高级功能，在多人开发的项目中，Github可以发挥更大的功效。</p><p>对于只是想保存自己的代码，暂且使用以上几个基础功能也算够用了。</p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github for windows 简介</title>
    <link href="/2017/02/04/Github%20for%20windows%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2017/02/04/Github%20for%20windows%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>在写代码调试时，经常会出现之前的代码可以用，但是修改后不知为何又出问题的情况。通常的办法是将可用的代码事先复制一份再进行修改，这样代码的管理并不科学。今天介绍使用Github来进行代码的版本控制，用专业的工具，提高工作效率。</p><p>这里介绍最简单的Github for windows 图形化软件，不需要学习使用各种命令，对于新手更容易入门。</p><h2 id="1-Github是什么"><a href="#1-Github是什么" class="headerlink" title="1.Github是什么"></a>1.Github是什么</h2><p>GitHub 是一个面向开源及私有软件项目的托管平台。</p><p>作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</p><p>GitHub for Windows 是一个 Metro 风格应用程序，集成了自包含版本的 Git，bash 命令行 shell，PowerShell 的 posh-git 扩展。GitHub 为 Windows 用户提供了一个基本的图形前端去处理大部分常用版本控制任务，可以创建版本库，向本地版本库递交补丁，在本地和远程版本库之间同步。微软也通过CodePlex向开发者提供 git 版本控制系统，而 GitHub 创造了一个更具有吸引力的 Windows 版本。</p><h2 id="2-注册Github"><a href="#2-注册Github" class="headerlink" title="2.注册Github"></a>2.注册Github</h2><p>登录网址：<a href="https://github.com/">https://github.com</a></p><p>如图所示，填写你的用户名，电子邮箱，密码即可注册完成。</p><p>点击上栏的加号创建一个程序仓库，用于存放代码。</p><p>点击New repository创建代码仓库:</p><p><img src="/images/b6dc68b1abf9bb70ae07f3bfbe7cec12.png"></p><p>创建完成后，这里介绍windows下不需要使用命令的方式进行代码管理。</p><h2 id="3-配置Github-for-windows"><a href="#3-配置Github-for-windows" class="headerlink" title="3.配置Github for windows"></a>3.配置Github for windows</h2><p>首先去Github for windows网站下载客户端：<a href="https://desktop.github.com/">https://desktop.github.com/</a></p><p>下载到的是一个在线安装器，运行后会 在线下载最新版本的软件进行安装。下载速度很慢，需要耐心等待。</p><p>安装完成后，即需要登陆之前注册的Github账号。登录完如图所示。要查看自己刚刚建立的代码仓库需要手动克隆仓库到本地。</p><p><img src="/images/ca7d7fc2564284b62e015c48d3461c38.png"></p><p>点击左上角加号，选择Clone，将会列出当前帐号的所有代码仓库，选择你的仓库，点击下方的按钮，会提示你要保存到本地的位置。</p><p><img src="/images/acf5faa2d48a9696d412bb55e3c5326e.png"></p><p>随后将会自动同步你的代码仓库到本地。</p><p>本地的文件夹中，编辑修改文件，软件将会自动监控文件变化。</p><p>当你完成一定的修改后，需要保存版本，可以进入Github for windows 。如图所示：</p><p><img src="/images/b818c9c3f2bf3454647278c4e6367017.png"></p><p>填写summary摘要和description说明，然后点击commit to master即可完成一个commit的创建。</p><p>完成一个commit后需要点击右上角的Sync来同步数据到Github网站，这样在不同的地点登陆都可以从网站下载最新的版本。</p><h2 id="4-代码管理"><a href="#4-代码管理" class="headerlink" title="4.代码管理"></a>4.代码管理</h2><p>Github for windows 不仅仅可以提交commit、同步，还可以在你代码出问题是，退回到原来commit的某个时间点。在代码仓库的History中，可以看到自己提交的commit，在这里选择某个commit点击右上方的revert可以恢复。</p><p>除此之外，Github还有跟多高级功能，在多人开发的项目中，Github可以发挥更大的功效。</p><p>对于只是想保存自己的代码，暂且使用以上几个基础功能也算够用了。</p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之中断原理</title>
    <link href="/2017/02/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86/"/>
    <url>/2017/02/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-中断简介"><a href="#1-中断简介" class="headerlink" title="1.中断简介"></a>1.中断简介</h2><p>中断，指计算机运行过程中，出现异常后，计算机停止当前工作保存当前状态，然后转向对这些异常的处理，在处理完成后再返回到停止时的状态，继续运行。</p><p><img src="/images/5b9f330cf86ae7252a0cafaea1f49f3b.png"></p><h2 id="2-S3C2440中断"><a href="#2-S3C2440中断" class="headerlink" title="2.S3C2440中断"></a>2.S3C2440中断</h2><p>S3C2440有60个中断源，这里只以其中的外部中断为例，以最简单的中断处理过程代码来分析中断。</p><p>中断处理之前需要先将各个IO引脚设置为中断功能，将指示灯的IO引脚设置为输出模式。在此之后，需要了解S3C2440的各组中断的指针位置。</p><p>如代码所示，在这段汇编代码中定义了各个中断的入口，本实验使用HandleIRQ这个入口地址，当出现中断信号时，程序跳转到0x18这个地址，然后再跳转到HandleIRQ这个函数。</p><p>HandleIRQ函数首先将当前寄存器状态入栈保存，然后再跳转到真正的中断服务程序。</p><p>在中断服务程序中，根据INTOFFSET寄存器的内容来做出相应的指示，在完成中断响应后需要手动清中断。</p><p>这样主程序不需要运行其他代码，中断的初始化、IO接口初始化也都在汇编文件中完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs markup">@******************************************************************************<br>@ File：head.S<br>@ 功能：初始化，设置中断模式、管理模式的栈，设置好中断处理函数<br>@******************************************************************************       <br>   <br>.extern     main<br>.text <br>.global _start <br>_start:<br>@******************************************************************************       <br>@ 异常向量，本程序中，除Reset和HandleIRQ外，其它异常都没有使用<br>@******************************************************************************       <br>    b   Reset<br><br>@ 0x04: 未定义指令中止模式的向量地址<br>HandleUndef:<br>    b   HandleUndef <br> <br>@ 0x08: 管理模式的向量地址，通过SWI指令进入此模式<br>HandleSWI:<br>    b   HandleSWI<br><br>@ 0x0c: 指令预取终止导致的异常的向量地址<br>HandlePrefetchAbort:<br>    b   HandlePrefetchAbort<br><br>@ 0x10: 数据访问终止导致的异常的向量地址<br>HandleDataAbort:<br>    b   HandleDataAbort<br><br>@ 0x14: 保留<br>HandleNotUsed:<br>    b   HandleNotUsed<br><br>@ 0x18: 中断模式的向量地址<br>    b   HandleIRQ<br><br>@ 0x1c: 快中断模式的向量地址<br>HandleFIQ:<br>    b   HandleFIQ<br><br>Reset:                  <br>    ldr sp, =4096           @ 设置栈指针，以下都是C函数，调用前需要设好栈<br>    bl  disable_watch_dog   @ 关闭WATCHDOG，否则CPU会不断重启<br>    <br>    msr cpsr_c, #0xd2       @ 进入中断模式<br>    ldr sp, =3072           @ 设置中断模式栈指针<br><br>    msr cpsr_c, #0xd3       @ 进入管理模式<br>    ldr sp, =4096           @ 设置管理模式栈指针，<br>                            @ 其实复位之后，CPU就处于管理模式，<br>                            @ 前面的“ldr sp, =4096”完成同样的功能，此句可省略<br><br>    bl  init_led            @ 初始化LED的GPIO管脚<br>    bl  init_irq            @ 调用中断初始化函数，在init.c中<br>    msr cpsr_c, #0x53       @ 设置I-bit=0，开IRQ中断<br>    <br>    ldr lr, =halt_loop      @ 设置返回地址<br>    ldr pc, =main           @ 调用main函数<br>halt_loop:<br>    b   halt_loop<br><br>HandleIRQ:<br>    sub lr, lr, #4                  @ 计算返回地址<br>    stmdb   sp!,    &#123; r0-r12,lr &#125;   @ 保存使用到的寄存器<br>                                    @ 注意，此时的sp是中断模式的sp<br>                                    @ 初始值是上面设置的3072<br>    <br>    ldr lr, =int_return             @ 设置调用ISR即EINT_Handle函数后的返回地址  <br>    ldr pc, =EINT_Handle            @ 调用中断服务函数，在interrupt.c中<br>int_return:<br>    ldmia   sp!,    &#123; r0-r12,pc &#125;^  @ 中断返回, ^表示将spsr的值复制到cpsr<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;s3c2440.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">EINT_Handle</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oft = INTOFFSET;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * K1,K2,K3,K4对应GPF1、GPF4、GPF2、GPF0</span><br><span class="hljs-comment"> *            即 EINT1, ETIN4, EINT2, EINT0</span><br><span class="hljs-comment"> *            oft为 1, 4, 2, 0 (对应INTMSK寄存器)</span><br><span class="hljs-comment"> */</span><br>    <br>    <span class="hljs-keyword">switch</span>( oft )<br>    &#123;<br>        <span class="hljs-comment">// K1被按下</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>        &#123;   <br>            GPBDAT |= (<span class="hljs-number">0xF</span>&lt;&lt;<span class="hljs-number">5</span>);   <span class="hljs-comment">// 所有LED熄灭</span><br>            GPBDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);      <span class="hljs-comment">// LED1点亮</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// K2被按下</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        &#123;   <br>            GPBDAT |= (<span class="hljs-number">0xF</span>&lt;&lt;<span class="hljs-number">5</span>);   <span class="hljs-comment">// 所有LED熄灭</span><br>            GPBDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);      <span class="hljs-comment">// LED2点亮</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// K3被按下</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        &#123;   <br>            GPBDAT |= (<span class="hljs-number">0xF</span>&lt;&lt;<span class="hljs-number">5</span>);   <span class="hljs-comment">// 所有LED熄灭</span><br>            GPBDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);      <span class="hljs-comment">// LED3点亮</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// K4被按下</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;   <br>            GPBDAT |= (<span class="hljs-number">0xF</span>&lt;&lt;<span class="hljs-number">5</span>);   <span class="hljs-comment">// 所有LED熄灭</span><br>            GPBDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>);      <span class="hljs-comment">// LED4点亮</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//清中断</span><br>    <span class="hljs-keyword">if</span>( oft == <span class="hljs-number">4</span> ) <br>        EINTPEND = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);   <span class="hljs-comment">// EINT4_7合用IRQ4</span><br>    SRCPND = <span class="hljs-number">1</span>&lt;&lt;oft;<br>    INTPND = <span class="hljs-number">1</span>&lt;&lt;oft;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>中断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之SDRAM学习</title>
    <link href="/2017/02/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8Bsdram%E5%AD%A6%E4%B9%A0/"/>
    <url>/2017/02/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8Bsdram%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>TQ2440开发板包括1片SDRAM、1片Nor Flash和1片Nand Flash。CPU可以直接控制SDRAM和片内Cache，通过IO控制电路连接Flash。程序可在SDRAM或Nor Flash上运行，但Nor Flash空间较小，因此，会添加一片大容量的Nand Flash。Nand Flash上的代码需要拷贝到内存才可以执行。</p><p>S3C2440的地址空间分为8个Bank，每个Bank有128M空间，其中有6个是ROM、SRAM这类存储器Bank，2个可以作为ROM、RAM、SDRAM等存储器Bank。S3C2440对外引出27根地址线，8个Bank总共1G空间，但地址总线为32位宽，因此会有剩余的3G地址，这部分作为寄存器地址或保留地址。系统上电后，首先从Bank0开始执行程序。</p><h2 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1.本节目标"></a>1.本节目标</h2><p>程序上电后，初始化内存，并使程序在内存中运行。</p><h2 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2.代码分析"></a>2.代码分析</h2><p>这段代码使用汇编完成以之前的LED程序做例子，本程序中，通过上电后初始化内存，并在内存运行代码，将程序下载如开发板后，会发现，这次的程序运行速度大大加快。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs markup">@*************************************************************************<br>@ File：head.S<br>@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行<br>@*************************************************************************<br>.equ MEM_CTL_BASE, 0x48000000<br>.equ SDRAM_BASE, 0x30000000<br>.text<br>.global _start<br>_start:<br>bl disable_watch_dog @ 关闭WATCHDOG，否则CPU会不断重启<br>bl memsetup @ 设置存储控制器<br>bl copy_steppingstone_to_sdram @ 复制代码到SDRAM中<br>ldr pc, =on_sdram @ 跳到SDRAM中继续执行<br>on_sdram:<br>ldr sp, =0x34000000 @ 设置堆栈<br>bl main<br>halt_loop:<br>b halt_loop<br>disable_watch_dog:<br>@ 往WATCHDOG寄存器写0即可<br>mov r1, #0x53000000<br>mov r2, #0x0<br>str r2, [r1]<br>mov pc, lr @ 返回<br>copy_steppingstone_to_sdram:<br>@ 将Steppingstone的4K数据全部复制到SDRAM中去<br>@ Steppingstone起始地址为0x00000000，SDRAM中起始地址为0x30000000<br>mov r1, #0<br>ldr r2, =SDRAM_BASE<br>mov r3, #4*1024<br>1:<br>ldr r4, [r1],#4 @ 从Steppingstone读取4字节的数据，并让源地址加4<br>str r4, [r2],#4 @ 将此4字节的数据复制到SDRAM中，并让目地地址加4<br>cmp r1, r3 @ 判断是否完成：源地址等于Steppingstone的未地址？<br>bne 1b @ 若没有复制完，继续<br>mov pc, lr @ 返回<br>memsetup:<br>@ 设置存储控制器以便使用SDRAM等外设<br>mov r1, #MEM_CTL_BASE @ 存储控制器的13个寄存器的开始地址<br>adrl r2, mem_cfg_val @ 这13个值的起始存储地址<br>add r3, r1, #52 @ 13*4 = 54<br>1:<br>ldr r4, [r2], #4 @ 读取设置值，并让r2加4<br>str r4, [r1], #4 @ 将此值写入寄存器，并让r1加4<br>cmp r1, r3 @ 判断是否设置完所有13个寄存器<br>bne 1b @ 若没有写成，继续<br>mov pc, lr @ 返回<br>.align 4<br>mem_cfg_val:<br>@ 存储控制器13个寄存器的设置值<br>.long 0x22011110 @ BWSCON<br>.long 0x00002e90 @ BANKCON0<br>.long 0x00002e90 @ BANKCON1<br>.long 0x00002e90 @ BANKCON2<br>.long 0x00002e90 @ BANKCON3<br>.long 0x00002e90 @ BANKCON4<br>.long 0x00002e90 @ BANKCON5<br>.long 0x00018005 @ BANKCON6<br>.long 0x00018005 @ BANKCON7<br>.long 0x00a60f44 @ REFRESH<br>.long 0x00000032 @ BANKSIZE<br>.long 0x00000030 @ MRSRB6<br>.long 0x00000030 @ MRSRB7<br></code></pre></td></tr></table></figure><p>程序需要烧写到Nor Flash上，然后设置Nor Flash启动。程序首先关闭看门狗，然后初始化内存，内存初始化完成后将Nor Flash的内容复制到SDRAM中继续执行。完成这些操作后进入main函数。</p><p>对内存的初始化即设置内存相关的寄存器，这部分需要根据不同的内存设置不同的参数。</p><p>复制代码并在内存上运行，就是把Nor Flash地址的内容直接复制到SDRAM中，然后需要设置堆栈指针。设置完成后只需修改PC指针到内存中的代码，程序便跳转到内存中运行。</p><p>这部分内容需要配合参考数据手册的存储器控制器部分，还要查看使用的内存芯片手册。在本文中，直接采用TQ2440提供的示例代码提供的内存初始化设置参数。 对于不同的开发板，可以根据开发板提供的内存初始化代码，直接修改参数部分即可。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>sdram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习之硬件准备篇</title>
    <link href="/2017/02/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A1%AC%E4%BB%B6%E5%87%86%E5%A4%87%E7%AF%87/"/>
    <url>/2017/02/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A1%AC%E4%BB%B6%E5%87%86%E5%A4%87%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>嵌入式学习包括的内容浩如烟海，很难把握主体路线，若是以项目为驱动，从实践中不断学习，从每个项目中补充所需的一些细节，就会事半功倍。同时，编程过程中也会积累调试经验，锻炼思考问题、解决问题的能力。</p><h2 id="1-嵌入式开发板"><a href="#1-嵌入式开发板" class="headerlink" title="1.嵌入式开发板"></a>1.嵌入式开发板</h2><p>我学习嵌入式使用的是天嵌公司的TQ2440开发板，核心是S3C2440嵌入式微处理器，板上包括触摸屏、网口、串口、音频接口等输入输出接口。</p><p>开发板的选择尽量选择提供程序开源代码的开发板，这样在学习中可以参考。</p><p>开发板的选择并不必须要和自己所学的教程完全一样，这样虽然在学习中会遇到更多的问题，但在解决问题的过程中将会学到更多的知识。</p><h2 id="2-J-Link下载器"><a href="#2-J-Link下载器" class="headerlink" title="2.J-Link下载器"></a>2.J-Link下载器</h2><p>J-Link下载器用于在裸机没有bootloader时，将编译的程序下载到开发板的Flash上。通过J-Link将电脑的USB接口和开发板的J-TAG接口连接。在下载完bootloader后，一般采用bootloader提供的串口、USB、网口等方式下载其他程序。</p><h2 id="3-USB转串口模块"><a href="#3-USB转串口模块" class="headerlink" title="3.USB转串口模块"></a>3.USB转串口模块</h2><p>目前的电脑上通常不带串行接口，但在和调试开发板程序时，串口是一个相当重要的通信接口。因此我们需要将电脑上的USB接口通过USB转串口模块和嵌入式开发板相连接，推荐使用开发板配套公司的串口模块，兼容性更有保证。</p><p>有了以上硬件准备后就可以开始准备软件环境了，在下一篇中，将介绍交叉编译环境、下载器配套的下载软件、程序的编译和下载等。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发板</tag>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于gcc的编程模板</title>
    <link href="/2017/01/31/%E5%9F%BA%E4%BA%8Egcc%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF/"/>
    <url>/2017/01/31/%E5%9F%BA%E4%BA%8Egcc%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>嵌入式编程中，需要预先设置好的东西比较多，在初学嵌入式时，经常发现在看完某方面文档后，仍然编写出的程序达不到预定效果，在学习更多知识后才会了解，原来还有一些特殊方面需要提前设置好。因此，本文作为裸机程序编写第一篇，介绍一下之后使用的程序模板。这个模板力求精简，发挥最基础的作用。主要包含以下文件：</p><p>github地址：<a href="https://github.com/EleVenPerfect/S3C2440/tree/master/none-OS/">https://github.com/EleVenPerfect/S3C2440/tree/master/none-OS/</a></p><p><img src="/images/039acf618569ea32c6f31fcc4c0a8ea8.png"></p><h2 id="1-head-s"><a href="#1-head-s" class="headerlink" title="1.head.s"></a>1.head.s</h2><p>head.s是整个程序的最最前面的程序，它以汇编语言编写，负责设置堆栈、设置系统时钟、设置内存、关闭看门狗等作用，在最后它引导程序进入main函数，开始执行main中的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markup">@******************************************************************************<br>@ File：head.S<br>@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行<br>@******************************************************************************       <br>   <br>.extern     main<br>.text <br>.global _start <br>_start:<br>Reset:                  <br>    ldr sp, =4096           @ 设置栈指针，以下都是C函数，调用前需要设好栈<br>    bl  disable_watch_dog   @ 关闭WATCHDOG，否则CPU会不断重启<br>    // bl是位置无关码，相当于：PCnew = PC + 偏移<br>    //                         PCnew = (4+8) + 0x28 = 0x34<br>    <br>    //ldr pc, =disable_watch_dog  /* 这样写将出错 */<br>    <br>    bl  clock_init          @ 设置MPLL，改变FCLK、HCLK、PCLK<br>    bl  memsetup            @ 设置存储控制器以使用SDRAM<br>    bl  copy_steppingstone_to_sdram     @ 复制代码到SDRAM中<br>    ldr pc, =on_sdram                   @ 跳到SDRAM中继续执行<br>on_sdram:<br>    ldr sp, =0x34000000     @ 设置栈指针<br>    ldr lr, =halt_loop      @ 设置返回地址<br>    ldr pc, =main           @ 调用main函数<br>halt_loop:<br>    b   halt_loop<br></code></pre></td></tr></table></figure><h2 id="2-init-c"><a href="#2-init-c" class="headerlink" title="2.init.c"></a>2.init.c</h2><p>在head.s中，我们看到，有直接跳转函数的代码，这部分在init.c内，是以c语言编写的负责实际完成关闭看门狗、设置内存、设置系统时钟、将程序复制到内存的。至于为什么不在head.s中实现，因为很多操作相对复杂，用C更便捷吧。它的源码较长，可以在我的github上查看。</p><p>需要注意的是，我的内存初始化代码适用于TQ2440开发板的内存，对于不同的内存芯片，需要修改参数。</p><h2 id="3-mian-c"><a href="#3-mian-c" class="headerlink" title="3.mian.c"></a>3.mian.c</h2><p>通常学习过编程的人都知道，main.c是整个程序的开始，这个模板也不例外，在完成最初级的设置后，程序跳转到main.c开始执行用户代码。</p><h2 id="4-Makefile"><a href="#4-Makefile" class="headerlink" title="4.Makefile"></a>4.Makefile</h2><p>Makefile是这个项目的负责编译控制的文件，在gcc下，通过使用Makefile可以使用make命令直接将程序编译成开发板需要的镜像文件。</p><p>同时，可以自定义其他指令，如模板文件中，定义了make clean命令，负责删除编译生成的文件，便于重新编译。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs := head.o init.o serial.o main.o<br><br><span class="hljs-section">000.bin: <span class="hljs-variable">$(objs)</span></span><br>arm-linux-ld -Ttext 0x000000 -o timer_elf <span class="hljs-variable">$^</span><br>arm-linux-objcopy -O binary -S timer_elf <span class="hljs-variable">$@</span><br>arm-linux-objdump -D -m arm timer_elf &gt; timer.dis<br><br><span class="hljs-section">%.o:%.c</span><br>arm-linux-gcc -Wall -nostdlib -O2 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">%.o:%.S</span><br>arm-linux-gcc -Wall -nostdlib -O2 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">clean:</span><br>rm -f timer.bin timer_elf timer.dis *.o<br></code></pre></td></tr></table></figure><p>同时，可以自定义其他指令，如模板文件中，定义了make clean命令，负责删除编译生成的文件，便于重新编译。</p><h2 id="5-S3C2440-h"><a href="#5-S3C2440-h" class="headerlink" title="5.S3C2440.h"></a>5.S3C2440.h</h2><p>S3C2440.h文件负责定义S3C2440处理器的各个寄存器地址，这样在编程中就不需要查看某个寄存器的地址，直接使用名称来表示。</p><p>还有为方便调试，预先编写好的串口程序，可作为程序的调试工具。在程序出现问题是，可通过串口打印数据判断错误原因。</p><p>欢迎关注我的公众号，和我一起学习嵌入式知识。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>gcc</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系结构简介</title>
    <link href="/2017/01/30/arm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    <url>/2017/01/30/arm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ARM处理器模式"><a href="#1-ARM处理器模式" class="headerlink" title="1.ARM处理器模式"></a>1.ARM处理器模式</h2><table style="height: 337px;" width="648" cellspacing="0" cellpadding="0"><tbody><tr><td width="175"><div>处理器工作模式</div></td><td width="109"><div>特权模式</div></td><td width="119"><div>异常模式</div></td><td width="165"><div>说明</div></td></tr><tr><td width="175" height="31"><div>用户（user）模式</div></td><td width="109" height="31"><div></div></td><td width="119" height="31"><div></div></td><td width="165" height="31"><div>用户程序运行模式</div></td></tr><tr><td width="175" height="34"><div>系统（system）模式</div></td><td rowspan="6" width="109" height="34"><div>该组模式下可以任意访问系统资源</div></td><td width="119" height="34"><div></div></td><td width="165" height="34"><div>运行特权级的操作系统任务</div></td></tr><tr><td width="175"><div>一般中断（IRQ）模式</div></td><td rowspan="5" width="119"><div>通常由系统异常状态切换进该组模式</div></td><td width="165"><div>普通中断模式</div></td></tr><tr><td width="175"><div>快速中断（FIQ）模式</div></td><td width="165"><div>快速中断模式</div></td></tr><tr><td width="175"><div>管理（supervisor）模式</div></td><td width="165"><div>提供操作系统使用的一种保护模式，swi命令状态</div></td></tr><tr><td width="175"><div>中止（abort）模式</div></td><td width="165"><div>虚拟内存管理和内存数据访问保护</div></td></tr><tr><td width="175"><div>未定义指令终止（undefined）模式</div></td><td width="165"><div>支持通过软件仿真硬件的协处理</div><div></div></td></tr></tbody></table><p>ARM处理器共有7种工作模式，除用户模式外，其余6种模式称为特权模式。ARM处理器一般有37个寄存器，包括31个通用寄存器和6个状态寄存器，在不同模式下，可以访问不同的寄存器。</p><p><img src="/images/de817ffd8a869e35661cd35c9a523d88.png"></p><p>这部分在学习初期只需简单了解，在后期Bootloader移植、操作系统移植时需要再返回来，仔细研究。因此，这里不做过多介绍。</p><h2 id="2-ARM处理器寻址方式"><a href="#2-ARM处理器寻址方式" class="headerlink" title="2.ARM处理器寻址方式"></a>2.ARM处理器寻址方式</h2><p>ARM处理器寻址方式主要分直接寻址、间接寻址和寄存器寻址这三类。这三类中，包括：立即寻址、寄存器寻址、寄存器间接寻址、寄存器偏移寻址、基址变址寻址、多寄存器寻址、堆栈寻址等。这部分在裸机程序编程中使用较少，根据后续使用中，根据需要学习。</p><h2 id="3-ARM指令集和Thumb指令集"><a href="#3-ARM指令集和Thumb指令集" class="headerlink" title="3.ARM指令集和Thumb指令集"></a>3.ARM指令集和Thumb指令集</h2><p>ARM处理器运行时可以分别运行两种指令集，在ARM指令集下包括6大类指令。包括跳转指令、数据处理指令、程序状态寄存器传输指令、Load&#x2F;Store指令、协处理器指令、异常中断产生指令。在ARM体系结构中。ARM指令集中的指令是32位的，其执行效率很高，位兼容总线宽度为16位的应用系统，ARM体系结构也支持16位的Thumb指令集。</p><p>Thumb指令集不是一个完整的体系结构，需要通用功能时可使用Thumb指令集，必要时可以借助ARM指令集实现更强大的功能。要实现Thumb子程序和ARM子程序互相调用需要遵循一定的编程规范。</p><p>一般情况下，Thumb代码所需的存储空间约为ARM代码的60%-70%；Thumb代码使用的指令数比ARM代码指令数多30-40%；使用16位存储器时Thumb代码速度更快；使用32位存储器时ARM代码速度更快；同时使用Thumb代码，存储器功耗会降低约30%。</p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>arm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交叉编译环境安装(下)环境配置</title>
    <link href="/2017/01/28/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2017/01/28/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-登陆系统"><a href="#1-登陆系统" class="headerlink" title="1.登陆系统"></a>1.登陆系统</h2><p>登录Linux系统，并输入”sudo -i”获取管理员权限。如图所示。</p><p><img src="/images/1c35bdf8ca2167d9de84941b8a63f647.png"></p><h2 id="2复制开发工具包"><a href="#2复制开发工具包" class="headerlink" title="2复制开发工具包"></a>2复制开发工具包</h2><p>将开发工具包使用文件共享，传到Linux中。如图所示：</p><p><img src="/images/cdfd8db7deab4e20540c1ac19a73f2e3.png"></p><h2 id="3-解压压缩包"><a href="#3-解压压缩包" class="headerlink" title="3.解压压缩包"></a>3.解压压缩包</h2><p>将当前目录切换到&#x2F;opt：”cd &#x2F;opt”</p><p>输入：”tar vxjf &#x2F;home&#x2F;atime&#x2F;EABI-4.3.3_EmbedSky_20100610.tar.bz2 -C &#x2F;”回车后效果如图所示：</p><p><img src="/images/d476828758ebf12085b273f406707093.png"></p><h2 id="4-修改系统环境变量"><a href="#4-修改系统环境变量" class="headerlink" title="4.修改系统环境变量"></a>4.修改系统环境变量</h2><p>移动到&#x2F;etc目录下：”cd &#x2F;etc”</p><p>使用vi编辑environment文件：”vi environment”</p><p>在PATH 末尾引号之前添加：”:&#x2F;opt&#x2F;EmbedSky&#x2F;4.3.3&#x2F;bin”</p><p>完成后保存退出按Esc输入：”:wq”</p><p>如图所示：</p><p><img src="/images/a2c198c0a69d0d909370a6a836e90c94.png"></p><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h2><p>此时可重启虚拟机登录测试：”arm-linux-gcc -v”</p><p>若出现exec arm-none-linux-gnueabi-gcc:not found</p><p>表示没有安装lsb-core，解决办法如下：</p><p>输出：”sudo apt-get install lsb-core”</p><p><img src="/images/92869fc68719af000810cd1675f0be94.png"></p><h2 id="6-测试gcc"><a href="#6-测试gcc" class="headerlink" title="6.测试gcc"></a>6.测试gcc</h2><p>在次重启虚拟机登录测试：”arm-linux-gcc -v”</p><p>注意，不要以root用户运行</p><p>出现如下显示，即为正确安装配置：</p><p><img src="/images/5e65c563a08ea0935cd247f24d8a2964.png"></p><h2 id="7-测试yaffs"><a href="#7-测试yaffs" class="headerlink" title="7.测试yaffs"></a>7.测试yaffs</h2><p>输入mkyaffs后连续按两次Tab键，出现如下则表示安装正确：</p><p><img src="/images/7e8c9a5b809b62dbe24ac1539aa50b96.png"></p><p>Linux操作系统下的交叉编译环境到这里就已经配置完成了。下一步还需要准备windows下的源代码浏览软件、J-Link烧录程序等的安装。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交叉编译环境安装（上）Samba服务安装</title>
    <link href="/2017/01/28/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%8A%EF%BC%89samba%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85/"/>
    <url>/2017/01/28/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%8A%EF%BC%89samba%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安装Samba"><a href="#1-安装Samba" class="headerlink" title="1.安装Samba"></a>1.安装Samba</h2><p>Samba服务用于共享目录，将Linux下的某个目录设置为局域网共享。</p><p>登录系统后，输入 “sudo -i” 输入密码获得管理员权限。如图所示：</p><p><img src="/images/b8637b5bd1937f8de69afc5ad99038f8.png"></p><p>更新软件列表，输入”apt-get update” 然后安装samba，输入”apt-get install samba”</p><p><img src="/images/8f33bd3a9ab89c9ff9e354edf2958457.png"></p><h2 id="2-配置Samba"><a href="#2-配置Samba" class="headerlink" title="2.配置Samba"></a>2.配置Samba</h2><p>先复制smb配置文件备份</p><p>输入”cp &#x2F;etc&#x2F;samba&#x2F;smb.conf &#x2F;etc&#x2F;samba&#x2F;smb.conf.bak”</p><p>如图所示结果</p><p><img src="/images/085550ecf724358178aad841511290c4.png"></p><p>输入”vi smb.conf”编辑smb.conf文件 在文件最末尾添加如下：</p><p><img src="/images/b632026ac49b0d76db4625305c1233e3.png"></p><p>按Esc后输入”：wq”保存退出即可 然后为smb服务添加用户密码；输入”smbpasswd -a atime”</p><p><img src="/images/7f66c5bdb1265987df91dbfbd101746f.png"></p><p>输入：”&#x2F;etc&#x2F;init.d&#x2F;samba start”启动samba服务</p><p><img src="/images/840dd4d92a2cd65044f91a661329b57c.png"></p><h2 id="3-Windows下连接共享目录"><a href="#3-Windows下连接共享目录" class="headerlink" title="3.Windows下连接共享目录"></a>3.Windows下连接共享目录</h2><p>Linux下输入:”ifconfig”查看本机IP</p><p>在windows系统下添加网络驱动器：</p><p><img src="/images/f5d726995cf7d7ef685f2a3803dc83a7.png"></p><p>选择添加网络驱动器，输入虚拟机IP地址 “\\192.168.1.105\share”输入用户名密码登录即可</p><p><img src="/images/86daec95d212d54453bf47ee79ebaea9.png"></p><p>添加完成后如图所示</p><p><img src="/images/eb4aa150afe6cb4d5f059ebe6b52f2dc.png"></p><p>至此，本片文章作为配置交叉编译环境的上篇，Samba服务安装配置完成，下一步将介绍安装交叉编译环境。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>linux</tag>
      
      <tag>sanba</tag>
      
      <tag>交叉编译环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习之Linux常用命令</title>
    <link href="/2017/01/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8Blinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/01/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8Blinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-pwd"><a href="#1-pwd" class="headerlink" title="1.pwd"></a>1.pwd</h2><p>pwd命令用于显示当前工作目录，如图所示：</p><p><img src="/images/5ab59904e3c3dcc7c858a38628fda3e5.png"></p><h2 id="2-man"><a href="#2-man" class="headerlink" title="2.man"></a>2.man</h2><p>man相当于我们使用软件时的帮助，使用方法如下：</p><p>man [option]</p><p>如图所示，我们想了解pwd命令的作用可以输入：</p><p><img src="/images/54bab1316b0b1e349d3e16a5643abd79.png"></p><p>阅读中，使用j、k按键进行上下滚动，q退出。</p><h2 id="3-cd"><a href="#3-cd" class="headerlink" title="3.cd"></a>3.cd</h2><p>cd命令用于切换当前目录，在控制台中，需要切换当前目录可以用如下命令：</p><p>cd [direction]</p><p><img src="/images/b1b74e1447d594f854ca1cf51a45437f.png"></p><p>需要说明的是，第二行所示中，</p><p>@符号前面的atime指的是当前用户；</p><p>@后的atime-pc指的是电脑名；</p><p>：后的&#x2F;etc指的是当前目录；</p><p>~符号表示当前用户目录。</p><p>当以普通用户登录时虎仔结尾显示$符号，</p><p>当以root用户登陆时，会显示#符号。</p><h2 id="4-sudo"><a href="#4-sudo" class="headerlink" title="4.sudo"></a>4.sudo</h2><p>ifconfig用于查看当前网络状态，可查看当前本机的IP地址如图所示：sudo命令是以其他用户执行某一命令，常用为:sudo -i：获取root权限。</p><p><img src="/images/4d920a951ffae0fe75063b3975ea71c4.png"></p><h2 id="5-ls-ll"><a href="#5-ls-ll" class="headerlink" title="5.ls&#x2F;ll"></a>5.ls&#x2F;ll</h2><p>ls命令用于列出当前目录的文件，</p><p>ll命令将会列出当前目录文件的详细信息。</p><p>ls命令还有附加的参数如-a会列出所有文件，-s按照文件大小排序列出，等这里不多介绍。</p><p><img src="/images/02b85a42123d14b90496ddb9a6cff3a8.png"></p><h2 id="6-mkdir"><a href="#6-mkdir" class="headerlink" title="6.mkdir"></a>6.mkdir</h2><p>mkdir用于创建文件夹使用方法如下：</p><p>在当前目录创建名为help的文件夹</p><p><img src="/images/8f4928a42fb3a172d5444faf194e2d47.png"></p><h2 id="7-cat"><a href="#7-cat" class="headerlink" title="7.cat"></a>7.cat</h2><p>cat主要有三个功能：</p><p>1.一次显示整个文件：$ cat filename</p><p>2.从键盘创建一个文件：$ cat &gt; filename</p><p>注意，此命令只能创建新文件,不能编辑已有文件。</p><p>3.将几个文件合并为一个文件： $cat file1 file2 &gt; file</p><p>如创建一个叫a.txt的文件：</p><p><img src="/images/d93a7019b9a83b8ee7c3bad785b0dd24.png"></p><p>输入命令后，会进入编辑状态，这时可以输入要保存在a.txt的文字，按Ctrl+c退出。打开共享目录中的a.txt文件如下：</p><p><img src="/images/b0ea5392312e0020f958c0fba48e936d.png"></p><h2 id="8-cat查看CPU信息"><a href="#8-cat查看CPU信息" class="headerlink" title="8.cat查看CPU信息"></a>8.cat查看CPU信息</h2><p>cat命令查看CPU信息：cat &#x2F;proc&#x2F;cpuinfo</p><p>如图所示：</p><p><img src="/images/ac7e00e35a400f9ae2c0d5866cb9438c.png"></p><h2 id="9-ifconfig"><a href="#9-ifconfig" class="headerlink" title="9.ifconfig"></a>9.ifconfig</h2><p>ifconfig用于查看当前网络状态，可查看当前本机的IP地址如图所示：</p><p><img src="/images/b1e2d0cef72e9dc24390eccdff1839aa.png"></p><h2 id="10-rm"><a href="#10-rm" class="headerlink" title="10.rm"></a>10.rm</h2><p>命令用来删除Linux系统中的文件或目录。通常情况下rm不会删除目录，通过指定参数-r或-R才可以删除目录。</p><p>常用参数如下：</p><p>-i：交互删除模式，删除文件前给提示；</p><p>-f：强制删除，忽略不存在的文件，从不给出提示；</p><p>-F：递归的删除目录下面文件以及子目录下文件；</p><p>-v：显示运行时状态；</p><p>-r&#x2F;-R：递归的删除目录下面文件以及子目录下文件。</p><p>更多参数请使用man rm查阅。</p><p>如删除1.txt文件，示例如下：</p><p>rm -rf [目录]：递归强制删除某一目录；</p><p><img src="/images/17c7159f311c76c38fea6fa1c4777ee6.png"></p><h2 id="11-mkdir"><a href="#11-mkdir" class="headerlink" title="11.mkdir"></a>11.mkdir</h2><p>rmdir用于删除空目录，若目录非空，会出错。实例删除help目录：</p><p><img src="/images/7086666c25f6938092d86b640d916f78.png"></p><h2 id="12-ps-ef"><a href="#12-ps-ef" class="headerlink" title="12.ps -ef"></a>12.ps -ef</h2><p>ps -ef用于查看进程，可以搭配|less使用：</p><p><img src="/images/68dc67095465e40c329c9b9a761fac84.png"></p><h2 id="13-mv"><a href="#13-mv" class="headerlink" title="13.mv"></a>13.mv</h2><p>mv：命令用于移动、重命名文件如将2.txt重命名为3.txt</p><p><img src="/images/59fbca880351d0d3e35c6fb75e035004.png"></p><h2 id="14-apt-get"><a href="#14-apt-get" class="headerlink" title="14.apt-get"></a>14.apt-get</h2><p>apt-get需要root权限，常用命令输入下：</p><p>sudo apt-get update：更新源</p><p>sudo apt-get install XXX：安装软件</p><p>sudo apt-get remove：卸载软件包</p><h2 id="15-logout"><a href="#15-logout" class="headerlink" title="15.logout"></a>15.logout</h2><p>logout用于退出登录账号。</p><p><img src="/images/758b2ac2ac299394a530b3288d64ff3e.png"></p><p>回车后显示如下：</p><p><img src="/images/cd6901151a30115617e4d7ac11e7fd0f.png"></p><h2 id="16-shutdown"><a href="#16-shutdown" class="headerlink" title="16.shutdown"></a>16.shutdown</h2><p>shutdown 命令用于关机，需要root权限运行，如下命令shutdown now</p><h2 id="17-reboot"><a href="#17-reboot" class="headerlink" title="17.reboot"></a>17.reboot</h2><p>reboot命令用于重启，需要root权限运行。</p><h2 id="18-chmod"><a href="#18-chmod" class="headerlink" title="18.chmod"></a>18.chmod</h2><p>chmod命令后接参数接文件-R递归操作</p><p>+r增加读权限</p><p>-删除写权限</p><p>+x增加执行权限</p><p>学习这个命令需要了解Linux的权限相关知识，将在以后的文章中讲解。</p><p>示例如下：</p><p>$ chmod u+x file：</p><p>给file的属主增加执行权限，</p><p>$ chmod -R u+r directory：递归地给directory目录下所有文件和子目录的属主分配读的权限。</p><p>更多详情需要学习权限知识后再学习。</p><p>学习Linux命令要常用man查看使用手册，通过阅读man文档可以更高效地学习这些知识。</p>]]></content>
    
    
    <categories>
      
      <category>embed</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习之Vi编辑器使用</title>
    <link href="/2017/01/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8Bvi%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <url>/2017/01/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8Bvi%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><p>Vi编辑器是Linux、Unix操作系统上最基本的文本编辑器，在通过终端、命令行等方式访问服务器时，Vi在系统管理中有着非常大的作用。本文将介绍Vi编辑器的基本操作。</p><h2 id="1-三种模式"><a href="#1-三种模式" class="headerlink" title="1.三种模式"></a>1.三种模式</h2><p>Vi编辑器有三种模式，分别为：命令模式、插入模式、末行模式。</p><p>1. 命令模式，可以输入各种命令，用于移动复制删除字符、字符串等。Vi启动时，进入此模式。 2. 输入模式，在命令模式下按I、i、A、a、O、o键进入输入模式，开始编辑文本。 3. 末行模式，执行待定命令，可用于保存或退出vi、列出行号等。通常将末行模式算作命令模式。 三种模式的切换如图所示：</p><p><img src="/images/3b20436338c2885fc0cffc24718f4796.png"></p><p>输入模式：</p><p><img src="/images/e3199a52ef40f71a8e3402de2d97c42f.png"> 命令模式：</p><p><img src="/images/646474a307faa08f270b2eab604288e3.png"> 末行模式：</p><p><img src="/images/28d9935b3d04bcfc5454e7856480ee77.png"> 按ESC键进入命令模式，按aio键进入输入模式，这样记忆就比较容易。</p><h2 id="2-进入退出Vi"><a href="#2-进入退出Vi" class="headerlink" title="2.进入退出Vi"></a>2.进入退出Vi</h2><p>在控制台，输入vi即可启动vi编辑器，除此之外，还可以使用vi filename 打开指定文件，若文件不存在则新建一个文件。还有其他命令这里不多解释，常用第二种命令。</p><h2 id="3-光标控制"><a href="#3-光标控制" class="headerlink" title="3.光标控制"></a>3.光标控制</h2><p>Vi编辑器使用一套不一样的方向键，在命令模式下：h：左移光标 j：下移光标 k：上移光标 l：右移光标 Ctrl+U：光标移动到首行 Ctrl+D：光标移动到末行 Ctrl+E：屏幕向下滚动一行 Ctrl+Y：屏幕向上滚动一行 Ctrl+F：屏幕向下滚动一屏 Ctrl+B：屏幕向上滚动一屏 ^：光标移动到行首 $：光标移动到行未 还有其他快捷键这里不多说，使用中多练习即可。</p><h2 id="4-保存退出"><a href="#4-保存退出" class="headerlink" title="4.保存退出"></a>4.保存退出</h2><p>末行模式下常用的几个保存退出相关命令：:wq：保存并退出 :q：直接退出，不保存 :q!：强制退出，不保存 :w：保存 :&#x2F; ：搜索 :n：定位到n行 :s&#x2F;old &#x2F;new：一行内替换old字符串为new一次 :s&#x2F;old&#x2F;new&#x2F;g：一行内替换所有old字符串为new :%s&#x2F;old&#x2F;new&#x2F;g：全文内替换所有old字符串为new :%s&#x2F;old&#x2F;new&#x2F;gc：替换是询问用户确认再替换 5.常用命令 x：删除当前光标字符X：删除光标前一字符 nx：删除当前光标后连续n个字符 nX：删除光标前连续n个字符 dd：删除行 ndd：删除n行 yy：复制当前行 nyy：复制当前n行 p：粘贴在当前行后 P：粘贴在当前行前 u：撤销操作 以上仅将Vi编辑器最基础最常用的使用做了介绍，对于嵌入式学习基本够用了，因此一些更高级的功能没有介绍。</p>]]></content>
    
    
    <categories>
      
      <category>embed</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习之安装Ubuntu Server</title>
    <link href="/2017/01/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%89%E8%A3%85ubuntu-server/"/>
    <url>/2017/01/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%89%E8%A3%85ubuntu-server/</url>
    
    <content type="html"><![CDATA[<h2 id="1-下载ubuntu-server"><a href="#1-下载ubuntu-server" class="headerlink" title="1.下载ubuntu server"></a>1.下载ubuntu server</h2><p>Ubuntu Server 16.04LTS网址：<a href="https://www.ubuntu.com/download%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">https://www.ubuntu.com/download如图所示：</a></p><p><img src="/images/img_5a79c6ae5eda9.png"></p><p>进入网页后选择Ubuntu Server</p><p>下载Ubuntu Server 16.04LTS</p><p>选择LTS版因为LTS为Ubuntu的长期支持版本，Ubuntu桌面版可以获得三年的服务支持，服务器版将会获得五年服务支持。</p><p><img src="/images/img_5a79c6ca0e8d0.png"></p><h2 id="2-安装虚拟机软件"><a href="#2-安装虚拟机软件" class="headerlink" title="2.安装虚拟机软件"></a>2.安装虚拟机软件</h2><p>因编程调试过程中需要在Windows系统环境下和Linux系统下不断切换，对于仅有一台PC的情况下建议使用虚拟机来配置Linux环境。本文以我使用的开源软件VBox为例介绍，在之后的开发中，将会一直使用这一环境。下载Oracle VM VirtualBox软件，并安装</p><p>如下图所示：</p><p><img src="/images/img_5a79c7547ba11.png"></p><p>百度搜索Vbox,进入官网选择download VirtualBox</p><p><img src="/images/img_5a79c74379f68.png"></p><p>安装步骤选择默认即可。</p><p>需要注意的是，将软件安装到非中文路径目录路，软件语言默认会是中文。</p><h2 id="3-创建虚拟机"><a href="#3-创建虚拟机" class="headerlink" title="3.创建虚拟机"></a>3.创建虚拟机</h2><p>根据向导一步步设置虚拟机即可，步骤如下：</p><p>创建虚拟机-</p><p><img src="/images/img_5a79c7d458e56.png"></p><p>设置名称、操作系统-</p><p><img src="/images/img_5a79c7f89042f.png"></p><p>设置内存大小-</p><p><img src="/images/img_5a79c81102a38.png"></p><p>创建新的虚拟硬盘-</p><p><img src="/images/img_5a79c8270514e.png"></p><p><img src="/images/img_5a79c837d5d6a.png"></p><p><img src="/images/img_5a79c85a3bcd4.png"></p><p><img src="/images/img_5a79c871791b0.png"></p><p> 创建完成后，建议修改设置，将启动顺序设置为光驱优先启动，将网络设置为桥接网络。</p><p><img src="/images/img_5a79c89086fda.png"></p><p>完成后可启动虚拟机，开始安装系统。</p><h2 id="4-安装Ubuntu-Server"><a href="#4-安装Ubuntu-Server" class="headerlink" title="4.安装Ubuntu Server"></a>4.安装Ubuntu Server</h2><p>安装过程建议使用英语环境。测试中，使用中文到安装系统步骤会出错，在此不再复述，直接采用英文环境安装。</p><p>启动虚拟机，添加刚刚下载的光盘为系统盘</p><p><img src="/images/img_5a79c8b645fa6.png"></p><p>选择英语</p><p><img src="/images/img_5a79c8d0ce0b2.png"></p><p>选择Install Ubuntu Server开始安装系统</p><p><img src="/images/img_5a79c8e932c26.png"></p><p>根据提示以默认设置即可。</p><p><img src="/images/img_5a79c905ca278.png"></p><p><img src="/images/img_5a79c93f50338.png"></p><p>耐心等待后，会出现要求设置主机名、用户名、密码</p><p><img src="/images/img_5a79c965be611.png"></p><p>设置用户名</p><p><img src="/images/img_5a79c9844ccc0.png"></p><p>设置密码、重复密码，如设置的是弱密码，需要确认使用弱密码，如图所示：</p><p><img src="/images/img_5a79c99d92834.png"></p><p>接下来采用默认设置一直到如下步骤：</p><p>卸载正在挂在的硬盘</p><p><img src="/images/img_5a79c9baee835.png"></p><p>使用整个磁盘，确认，确认</p><p><img src="/images/img_5a79c9d7aa08c.png"></p><p>选择是，开始写入磁盘</p><p><img src="/images/img_5a79c9f22223e.png"></p><p>等待进度</p><p><img src="/images/img_5a79ca09d5fac.png"></p><p>不设置代理，直接确认即可</p><p><img src="/images/img_5a79ca2e150c9.png"></p><p>等待安装进度</p><p><img src="/images/img_5a79ca52d3fe1.png"></p><p>本地环境使用选择不更新系统亦可</p><p><img src="/images/img_5a79ca6e91281.png"></p><p>下一步默认设置，安装软件</p><p><img src="/images/img_5a79ca8a6d4fc.png"></p><p>继续等待</p><p><img src="/images/img_5a79caa1d0d62.png"></p><p>确认安装GRUB</p><p><img src="/images/img_5a79cab676a94.png"></p><p>继续，卸载光盘并重启</p><p><img src="/images/img_5a79cacc248ff.png"></p><p>安装至此完成。</p><h2 id="5-进入系统"><a href="#5-进入系统" class="headerlink" title="5.进入系统"></a>5.进入系统</h2><p>开启虚拟机后不需要选择，直接默认就可以引导Ubuntu，</p><p>敲回车或等待几秒钟后自动开始引导系统</p><p><img src="/images/img_5a79cafe83a4d.png"></p><p>准备登录系统，输入用户名，回车</p><p><img src="/images/img_5a79cb1cf3978.png"></p><p>输入密码，回车</p><p>需要注意的是，输入密码过程中，处于安全考录控制台并不会显示输入结果。</p><p><img src="/images/img_5a79cb346170e.png"></p><p>显示以上图片结果即为系统登陆成功。</p><p>要关闭虚拟机，可以点击窗口的关闭按钮，选择正常关闭即可。</p><p>至此，Ubuntu Server16.04便安装完成了，在接下来的文章中，将会介绍如何安装配置服务器，在虚拟机上安装交叉编译环境。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
      <category>bootloader</category>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习之Windows环境常用软件</title>
    <link href="/2017/01/26/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8Bwindows%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    <url>/2017/01/26/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8Bwindows%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>本节介绍嵌入式开发中，windows系统下需要安装的软件。</p><h2 id="1-J-Link"><a href="#1-J-Link" class="headerlink" title="1.J-Link"></a>1.J-Link</h2><p>J-Link用于将bootloader下载到开发板NOR Flash上，或在裸板开发中，直接将程序下载到开发板。</p><p>安装J-Link软件如图所示：</p><p><img src="/images/img_5a79c46636595.png"></p><p>直接下一步、下一步即可安装完成。</p><p>接下来在开始菜单中，找到J-Flash ARM，如图所示：</p><p><img src="/images/img_5a79c47462d8e.png"></p><p>打开File-Open Project</p><p>打开开发板所提供的工程</p><p><img src="/images/img_5a79c45073c2d.png"></p><p>如图所示：</p><p><img src="/images/img_5a79c4fc7cca1.png"></p><p>点击Option-Project Setting-Flash</p><p>设置为如图所示：</p><p><img src="/images/img_5a79c50b50ee5.png"></p><p>打开开发板，连接上J-Link，确认开发板是从NOR Flash启动的。</p><p>点击Target-Connect看到如下提示即为成功：</p><p><img src="/images/img_5a79c514b918c.png"></p><h2 id="2-串口驱动"><a href="#2-串口驱动" class="headerlink" title="2.串口驱动"></a>2.串口驱动</h2><p>串口驱动程序安装比较简单，需要注意的是，某些串口驱动因自身设计问题，安装串口驱动时USB转串口插在哪个USB口，在将来使用时也只能使用那个USB口插USB转串口模块。安装完成后，在设备管理器会看到分配的串口：</p><p><img src="/images/img_5a79c53e906ef.png"></p><h2 id="3-TQBoardDNW"><a href="#3-TQBoardDNW" class="headerlink" title="3.TQBoardDNW"></a>3.TQBoardDNW</h2><p>TQBoardDNW是天嵌公司开发的下载软件，使用这个软件可以更方便的下载镜像，安装步骤比较简单，这里就不多说。软件安装完成后还需要安装USB下载驱动，完成后软件即可正常使用。</p><p><img src="/images/img_5a79c54b87049.png"></p><p>串口连接成功后，重启开发板，会看到如下：</p><p><img src="/images/img_5a79c57533f3c.png"></p><p>驱动安装方法：找到USB下载驱动目录，右击TQ2440_Board.inf-安装即可。安装过程中，会提示没有数字签名若系统强制需要数字签名，windows8系统可以在高级启动中禁用驱动强制数字签名。安装完成后设备管理器内出现：</p><p><img src="/images/img_5a79c57e112d4.png"></p><p>即为安装成功，重启系统后再测试没问题即可。</p><h2 id="4-Source-Insight"><a href="#4-Source-Insight" class="headerlink" title="4.Source Insight"></a>4.Source Insight</h2><p>Source Insight用于在windows下方便地查看项目源代码，对于阅读Linux内核源码、Uboot源码有很大帮助。安装后如图所示：</p><p><img src="/images/img_5a79c585d32fc.png"></p><h2 id="5-SecureCRT"><a href="#5-SecureCRT" class="headerlink" title="5.SecureCRT"></a>5.SecureCRT</h2><p>SecureCRT用于电脑和开发板连接串口，通过SecureCRT软件设置串口信息，连接到开发板上。如果使用天嵌开发板，可以直接使用TQBoardDNW作为串口下载程序，此软件可不安装。</p><p><img src="/images/img_5a79c58c59872.png"></p><h2 id="另："><a href="#另：" class="headerlink" title="另："></a>另：</h2><p>还有一些软件在学习嵌入式时会有人说要安装ADS，在这里，因为我的学习路线主要采用Linux下主要使用Gcc编译器，因此不再使用ADS，况且ADS在编译bootloader、Linux内核时有诸多不便，就不再安装这款软件了。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>windows软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式学习路线</title>
    <link href="/2017/01/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2017/01/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>嵌入式涉及的范围广泛，我的公众号主要介绍软件方面的学习，在学习之初先主要介绍下我自己的学习路线，供大家参考。如有疏漏之处，请多指点。</p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><p>学习嵌入式之前，最好有一些单片机开发经验，如对数字电路要熟悉组合逻辑电路、时序逻辑电路的基础知识。除此之外对模拟电路也应了解一二。如三极管的放大作用、场效应管、功率放大电路等基础电路。除对电子专业基础课的了解外，还要有C语言程序的编程经验，熟悉C语言的语法规范，能够分析理解程序的执行过程。</p><h2 id="2-裸机程序"><a href="#2-裸机程序" class="headerlink" title="2.裸机程序"></a>2.裸机程序</h2><p>ARM嵌入式裸机程序</p><p>在学习之初需要先学习ARM裸机编程，学习嵌入式系统的体系结构，要熟悉ARM处理器的七种工作模式、寻址模式、ARM指令集和Thumb指令集。学习C语言与汇编程序混合编程的方法，对于今后学习操作系统的移植有很大作用。嵌入式裸机编程需要主要会设计：GPIO的使用、中断系统原理、串口通信原理、系统时钟和定时器、LCD接口应用、Nand Flash接口应用等方面。</p><h2 id="3-Bootloader移植"><a href="#3-Bootloader移植" class="headerlink" title="3.Bootloader移植"></a>3.Bootloader移植</h2><p>Bootloader移植Bootloader的学习会涉及Bootloader的作用、常见Bootloader介绍。在此之后主要会以Uboot为实例，深入研究Uboot的启动流程。从Bootloader对硬件的初始化，到加载Bootloader到RAM，再到内存映射、调用内核结束。这里所说的流程均以S3C2440的Uboot为例。</p><h2 id="4-Linux内核"><a href="#4-Linux内核" class="headerlink" title="4.Linux内核"></a>4.Linux内核</h2><p>Linux内核的学习将会以理解内核工作流程为中心，分别介绍Linux内核的组成结构、内核的配置方法、内核移植的基础知识。学习移植Linux内核后讲介绍Linux根文件系统，学习Busybox，理解Linux操作系统的引导流程。</p><h2 id="5-驱动移植"><a href="#5-驱动移植" class="headerlink" title="5.驱动移植"></a>5.驱动移植</h2><p>驱动移植驱动移植部分会以实践为基础，详细介绍Linux操作系统下的驱动移植方法。</p><h2 id="6-Linux应用开发"><a href="#6-Linux应用开发" class="headerlink" title="6.Linux应用开发"></a>6.Linux应用开发</h2><p>Linux应用开发Linux应用开发这部分会介绍shell的使用、Linux网络编程（TCP、UDP）、文件操作、进程间通信等知识。这部分将会以实战操作为导向，通过一个个实验逐渐学习。</p><p>本文介绍的是以我的学习计划为参考，以S3C2440为实验平台。对于不同的硬件平台或不同的职业方向，建议根据自己的需要适当调整。</p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>msp430</category>
      
      <category>mcu</category>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATIME_51_MCU函数库</title>
    <link href="/2017/01/19/atime_51_mcu%E5%87%BD%E6%95%B0%E5%BA%93/"/>
    <url>/2017/01/19/atime_51_mcu%E5%87%BD%E6%95%B0%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>ATIME 51 单片机开发库是ATIME于2014年初开始的一个STC51单片机开发库项目。该项目致力于设计出一整套51单片机通用函数库，以便于人们进行51单片机项目开发。</p><p>项目首页地址：<a href="http://elevenperfect.github.io/ATIME/_51/_MCU/">http://elevenperfect.github.io/ATIME\_51\_MCU/</a></p><p>项目源码地址：<a href="https://github.com/EleVenPerfect/ATIME/_51/_MCU">https://github.com/EleVenPerfect/ATIME\_51\_MCU</a></p><p><img src="/images/post56.png"></p>]]></content>
    
    
    <categories>
      
      <category>51mcu</category>
      
      <category>mcu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之点亮LED</title>
    <link href="/2012/02/01/91/"/>
    <url>/2012/02/01/91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-GPIO介绍"><a href="#1-GPIO介绍" class="headerlink" title="1.GPIO介绍"></a>1.GPIO介绍</h2><p>S3C2440A包含130个多功能输入输出引脚，共分为9组：GPA~GPJ。通过查看数据手册，可知每组接口有GPxCON，端口配置寄存器；GPxDAT，端口数据寄存器；GPxUP，端口上拉寄存器；但并不是每组GPIO都包含全部寄存器。除此之外，还有杂项控制寄存器、外部中断寄存器等。</p><h2 id="2-本节目标"><a href="#2-本节目标" class="headerlink" title="2.本节目标"></a>2.本节目标</h2><p>本节介绍最简单的GPIO应用——点亮LED灯。在程序模板的基础下，修改程序。需要准备的文档：S3C2440数据手册，TQ2440开发板电路原理图。</p><p>通过查看电路原理图，TQ2440的LED在GPB5~GPB8</p><p>通过查看数据手册，要控制一个GPIO需要配置GPxDAT、GPxCON、GPxUP三组寄存器即可。</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="/images/f9562fe7505921626252a5a668db726d.png"></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/images/5657469ede72fa7915a54d82a11db2be.png"></h1><h2 id="3-程序分析"><a href="#3-程序分析" class="headerlink" title="3.程序分析"></a>3.程序分析</h2><p>程序已保存在GPIO文件夹中，可在我的Github中浏览，这里只介绍关键的部分。</p><p>宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span><br></code></pre></td></tr></table></figure><p>这部分主要为定义4个GPIO的设置准备，将这4个IO接口设置为输出模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GPBCON = GPB5_out | GPB6_out | GPB7_out | GPB8_out;<br></code></pre></td></tr></table></figure><p>在主程序中，先设置GPB的5~8位设置为输出，通过逻辑与，生成需要设置给GPBCON的最终结果。</p><p>因GPBUP寄存器默认值为0x0，即使能上拉功能，在此不需修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs clike">while(1)<br>&#123;<br>    i++;<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;5);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;5);<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;6);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;6);<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;7);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;7);<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;8);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;8);<br>    delay(500);<br>&#125;<br></code></pre></td></tr></table></figure><p>在设置好GPBCON后，设置一个大循环，给GPBDAT设置不同的值来控制LED引脚的高低电位。程序效果为LED亮500ms暗500ms。通过一个变量的最低位值来确定亮暗状态。</p><p>程序中，i变量数值范围为0~255，但实际并未设置超出范围后重置变量值，这是因为在i到达255后再加1其值会变为0。</p><p><img src="/images/7224a0711f41d03a739a11fb07a83405.png"></p><p><img src="/images/7224a0711f41d03a739a11fb07a83405.png"></p><p>点亮LED通常是学习单片机的第一节课，ARM裸机程序也是如此。程序中，有部分代码是在后面学习才会涉及到的，这里只需会用即可。建议自己再翻阅芯片数据手册，更详细地了解GPIO的使用规则。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>led</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式裸机程序之点亮LED</title>
    <link href="/2012/02/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%82%B9%E4%BA%AELED/"/>
    <url>/2012/02/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%82%B9%E4%BA%AELED/</url>
    
    <content type="html"><![CDATA[<h2 id="1-GPIO介绍"><a href="#1-GPIO介绍" class="headerlink" title="1.GPIO介绍"></a>1.GPIO介绍</h2><p>S3C2440A包含130个多功能输入输出引脚，共分为9组：GPA~GPJ。通过查看数据手册，可知每组接口有GPxCON，端口配置寄存器；GPxDAT，端口数据寄存器；GPxUP，端口上拉寄存器；但并不是每组GPIO都包含全部寄存器。除此之外，还有杂项控制寄存器、外部中断寄存器等。</p><h2 id="2-本节目标"><a href="#2-本节目标" class="headerlink" title="2.本节目标"></a>2.本节目标</h2><p>本节介绍最简单的GPIO应用——点亮LED灯。在程序模板的基础下，修改程序。需要准备的文档：S3C2440数据手册，TQ2440开发板电路原理图。</p><p>通过查看电路原理图，TQ2440的LED在GPB5~GPB8</p><p>通过查看数据手册，要控制一个GPIO需要配置GPxDAT、GPxCON、GPxUP三组寄存器即可。</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="/images/f9562fe7505921626252a5a668db726d.png"></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/images/5657469ede72fa7915a54d82a11db2be.png"></h1><h2 id="3-程序分析"><a href="#3-程序分析" class="headerlink" title="3.程序分析"></a>3.程序分析</h2><p>程序已保存在GPIO文件夹中，可在我的Github中浏览，这里只介绍关键的部分。</p><p>宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span><br></code></pre></td></tr></table></figure><p>这部分主要为定义4个GPIO的设置准备，将这4个IO接口设置为输出模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GPBCON = GPB5_out | GPB6_out | GPB7_out | GPB8_out;<br></code></pre></td></tr></table></figure><p>在主程序中，先设置GPB的5~8位设置为输出，通过逻辑与，生成需要设置给GPBCON的最终结果。</p><p>因GPBUP寄存器默认值为0x0，即使能上拉功能，在此不需修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs clike">while(1)<br>&#123;<br>    i++;<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;5);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;5);<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;6);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;6);<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;7);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;7);<br>    if( i%2==1 )<br>        GPBDAT |=(1&lt;&lt;8);<br>    else<br>        GPBDAT &amp;=~(1&lt;&lt;8);<br>    delay(500);<br>&#125;<br></code></pre></td></tr></table></figure><p>在设置好GPBCON后，设置一个大循环，给GPBDAT设置不同的值来控制LED引脚的高低电位。程序效果为LED亮500ms暗500ms。通过一个变量的最低位值来确定亮暗状态。</p><p>程序中，i变量数值范围为0~255，但实际并未设置超出范围后重置变量值，这是因为在i到达255后再加1其值会变为0。</p><p><img src="/images/7224a0711f41d03a739a11fb07a83405.png"></p><p><img src="/images/7224a0711f41d03a739a11fb07a83405.png"></p><p>点亮LED通常是学习单片机的第一节课，ARM裸机程序也是如此。程序中，有部分代码是在后面学习才会涉及到的，这里只需会用即可。建议自己再翻阅芯片数据手册，更详细地了解GPIO的使用规则。</p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
      <category>embed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>led</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
